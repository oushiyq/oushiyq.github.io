<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>iOS Core Animation Advanced Techniques阅读笔记（二） | Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC]
一、隐式动画1.1 事务隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画
动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。
Core Animation在每个run loop周期中自动开始一次新的事务，即使你不显式地使用[CATransaction begin]开始一次事务，在一个特定run loop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS Core Animation Advanced Techniques阅读笔记（二）">
<meta property="og:url" content="http://yoursite.com/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description" content="[TOC]
一、隐式动画1.1 事务隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画
动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。
Core Animation在每个run loop周期中自动开始一次新的事务，即使你不显式地使用[CATransaction begin]开始一次事务，在一个特定run loop">
<meta property="og:updated_time" content="2018-07-23T05:07:50.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS Core Animation Advanced Techniques阅读笔记（二）">
<meta name="twitter:description" content="[TOC]
一、隐式动画1.1 事务隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画
动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。
Core Animation在每个run loop周期中自动开始一次新的事务，即使你不显式地使用[CATransaction begin]开始一次事务，在一个特定run loop">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Core-Animation/" style="font-size: 10px;">Core Animation</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/" class="article-date">
  	<time datetime="2018-07-22T15:21:45.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS Core Animation Advanced Techniques阅读笔记（二）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u9690_u5F0F_u52A8_u753B"><a href="#u4E00_u3001_u9690_u5F0F_u52A8_u753B" class="headerlink" title="一、隐式动画"></a>一、隐式动画</h1><h2 id="1-1__u4E8B_u52A1"><a href="#1-1__u4E8B_u52A1" class="headerlink" title="1.1 事务"></a>1.1 事务</h2><p>隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画</p>
<p>动画执行的时间取决于当前<em>事务</em>的设置，动画类型取决于<em>图层行为</em>。</p>
<p>Core Animation在每个<em>run loop</em>周期中自动开始一次新的事务，即使你不显式地使用<code>[CATransaction begin]</code>开始一次事务，在一个特定run loop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。</p>
<h2 id="1-2__u5B8C_u6210_u5757"><a href="#1-2__u5B8C_u6210_u5757" class="headerlink" title="1.2 完成块"></a>1.2 完成块</h2><p>基于<code>UIView</code>的block的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。</p>
<h2 id="1-3__u56FE_u5C42_u884C_u4E3A"><a href="#1-3__u56FE_u5C42_u884C_u4E3A" class="headerlink" title="1.3 图层行为"></a>1.3 图层行为</h2><ul>
<li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li>
<li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li>
</ul>
<h2 id="1-4__u5448_u73B0_u4E0E_u6A21_u578B"><a href="#1-4__u5448_u73B0_u4E0E_u6A21_u578B" class="headerlink" title="1.4 呈现与模型"></a>1.4 呈现与模型</h2><p>设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p>
<p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p>
<p>每个图层属性的显示值都被存储在一个叫做 <strong>呈现图层</strong> 的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p>
<p><strong>呈现树 </strong>通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p>
<p> 两种情况下呈现图层会变得很有用，一个是<strong>同步动画</strong>，一个是处理<strong>用户交互</strong>。</p>
<ul>
<li>如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<h1 id="u4E8C_u3001_u663E_u5F0F_u52A8_u753B"><a href="#u4E8C_u3001_u663E_u5F0F_u52A8_u753B" class="headerlink" title="二、显式动画"></a>二、显式动画</h1><h2 id="2-1__u5C5E_u6027_u52A8_u753B"><a href="#2-1__u5C5E_u6027_u52A8_u753B" class="headerlink" title="2.1 属性动画"></a>2.1 属性动画</h2><p>属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：<em>基础</em>和<em>关键帧</em>。</p>
<p>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是<code>CABasicAnimation</code>最主要的功能。</p>
<p>像所有的<code>NSObject</code>子类一样，<code>CAAnimation</code>实现了KVC（键-值-编码）协议，于是你可以用<code>-setValue:forKey:</code>和<code>-valueForKey:</code>方法来存取属性。但是<code>CAAnimation</code>有一个与众不同的特性：它更像一个<code>NSDictionary</code>，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<h2 id="2-2__u5173_u952E_u5E27_u52A8_u753B"><a href="#2-2__u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="2.2 关键帧动画"></a>2.2 关键帧动画</h2><p><code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code>那样把<code>fromValue</code>设为<code>nil</code>）。</p>
<h2 id="2-3__u865A_u62DF_u5C5E_u6027"><a href="#2-3__u865A_u62DF_u5C5E_u6027" class="headerlink" title="2.3 虚拟属性"></a>2.3 虚拟属性</h2><p><code>transform.rotation</code>而不是<code>transform</code>做动画的好处如下：</p>
<ul>
<li>我们可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置<code>byValue</code>而不是<code>toValue</code>）。</li>
<li>可以不用创建<code>CATransform3D</code>，而是使用一个简单的数值来指定角度。</li>
<li>不会和<code>transform.position</code>或者<code>transform.scale</code>冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<p><code>transform.rotation</code>属性有一个奇怪的问题是它其实<em>并不存在</em>。这是因为<code>CATransform3D</code>并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，<code>transform.rotation</code>实际上是一个<code>CALayer</code>用于处理动画变换的<em>虚拟</em>属性。</p>
<h2 id="2-4__u52A8_u753B_u7EC4"><a href="#2-4__u52A8_u753B_u7EC4" class="headerlink" title="2.4 动画组"></a>2.4 动画组</h2><p><code>CABasicAnimation</code>和<code>CAKeyframeAnimation</code>仅仅作用于单独的属性，而<code>CAAnimationGroup</code>可以把这些动画组合在一起。</p>
<h2 id="2-5__u8FC7_u6E21"><a href="#2-5__u8FC7_u6E21" class="headerlink" title="2.5 过渡"></a>2.5 过渡</h2><p><code>CATransition</code>，同样是另一个<code>CAAnimation</code>的子类，和别的子类不同，<code>CATransition</code>有一个<code>type</code>和<code>subtype</code>来标识变换效果。<code>type</code>属性是一个<code>NSString</code>类型，可以被设置成如下类型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CATransitionFade</span> </span><br><span class="line">k<span class="built_in">CATransitionMoveIn</span> </span><br><span class="line">k<span class="built_in">CATransitionPush</span> </span><br><span class="line">k<span class="built_in">CATransitionReveal</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6__u9690_u5F0F_u8FC7_u6E21"><a href="#2-6__u9690_u5F0F_u8FC7_u6E21" class="headerlink" title="2.6 隐式过渡"></a>2.6 隐式过渡</h2><p><code>CATransision</code>可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。</p>
<h2 id="2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B"><a href="#2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B" class="headerlink" title="2.7 对图层树的动画"></a>2.7 对图层树的动画</h2><p><code>CATransition</code>并不作用于指定的图层属性。</p>
<h2 id="2-8__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#2-8__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="2.8 自定义动画"></a>2.8 自定义动画</h2><p><code>UIView</code>过渡方法中<code>options</code>参数可以由如下常量指定：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlUp</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlDown</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromTop</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromBottom</span></span><br></pre></td></tr></table></figure>
<h2 id="2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B"><a href="#2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B" class="headerlink" title="2.9 在动画过程中取消动画"></a>2.9 在动画过程中取消动画</h2><p>动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<h1 id="u4E09_u3001_u56FE_u5C42_u65F6_u95F4"><a href="#u4E09_u3001_u56FE_u5C42_u65F6_u95F4" class="headerlink" title="三、图层时间"></a>三、图层时间</h1><h2 id="3-1_CAMediaTiming_u534F_u8BAE"><a href="#3-1_CAMediaTiming_u534F_u8BAE" class="headerlink" title="3.1 CAMediaTiming协议"></a>3.1 <code>CAMediaTiming</code>协议</h2><p><code>CAMediaTiming</code>协议定义了在一段动画内用来控制逝去时间的属性的集合，<code>CALayer</code>和<code>CAAnimation</code>都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>
<h2 id="3-2__u76F8_u5BF9_u65F6_u95F4"><a href="#3-2__u76F8_u5BF9_u65F6_u95F4" class="headerlink" title="3.2 相对时间"></a>3.2 相对时间</h2><p> 每次讨论到Core Animation，时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>
<h2 id="3-3_fillMode"><a href="#3-3_fillMode" class="headerlink" title="3.3 fillMode"></a>3.3 <code>fillMode</code></h2><p> <code>fillMode</code>是一个<code>NSString</code>类型，可以接受如下四种常量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAFillModeForwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBackwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBoth</span></span><br><span class="line">k<span class="built_in">CAFillModeRemoved</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4"><a href="#3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4" class="headerlink" title="3.4 层级关系时间"></a>3.4 层级关系时间</h2><p>对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。</p>
<h2 id="3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4"><a href="#3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4" class="headerlink" title="3.5 全局时间和本地时间"></a>3.5 全局时间和本地时间</h2><p> CoreAnimation有一个<em>全局时间</em>的概念，也就是所谓的<em>马赫时间</em>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTimeInterval</span> time = <span class="built_in">CACurrentMediaTime</span>();</span><br></pre></td></tr></table></figure>
<p> 这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的<code>CAAnimations</code>（基于马赫时间）同样也会暂停。</p>
<h2 id="3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB"><a href="#3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB" class="headerlink" title="3.6 暂停，倒回和快进"></a>3.6 暂停，倒回和快进</h2><p>给图层添加一个<code>CAAnimation</code>实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。</p>
<h2 id="3-7__u624B_u52A8_u52A8_u753B"><a href="#3-7__u624B_u52A8_u52A8_u753B" class="headerlink" title="3.7 手动动画"></a>3.7 手动动画</h2><p><code>timeOffset</code>一个很有用的功能在于它可以让你手动控制动画进程，通过设置<code>speed</code>为0，可以禁用动画的自动播放，然后来使用<code>timeOffset</code>来来回显示动画序列。这可以使得运用手势来手动控制动画变得很简单。</p>
<h1 id="u56DB_u3001_u7F13_u51B2"><a href="#u56DB_u3001_u7F13_u51B2" class="headerlink" title="四、缓冲"></a>四、缓冲</h1><h2 id="4-1__u52A8_u753B_u901F_u5EA6"><a href="#4-1__u52A8_u753B_u901F_u5EA6" class="headerlink" title="4.1 动画速度"></a>4.1 动画速度</h2><p>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">velocity</span> = change / <span class="built_in">time</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2_CAMediaTimingFunction"><a href="#4-2_CAMediaTimingFunction" class="headerlink" title="4.2 CAMediaTimingFunction"></a>4.2 <code>CAMediaTimingFunction</code></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAMediaTimingFunctionLinear</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseIn</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseOut</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span></span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionDefault</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2"><a href="#4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2" class="headerlink" title="4.3 UIView的动画缓冲"></a>4.3 <code>UIView</code>的动画缓冲</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseIn</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveLinear</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B"><a href="#4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="4.4 缓冲和关键帧动画"></a>4.4 缓冲和关键帧动画</h2><p> <code>CAKeyframeAnimation</code>有一个<code>NSArray</code>类型的<code>timingFunctions</code>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于<code>keyframes</code>数组的元素个数<em>减一</em>，因为它是描述每一帧之间动画速度的函数。</p>
<p><code>CAKeyframeAnimation</code>可以用来避开<code>CAMediaTimingFunction</code>的限制，创建完全自定义的缓冲函数。</p>
<h1 id="u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B"><a href="#u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B" class="headerlink" title="五、基于定时器的动画"></a>五、基于定时器的动画</h1><h2 id="5-1__u5B9A_u65F6_u5E27"><a href="#5-1__u5B9A_u65F6_u5E27" class="headerlink" title="5.1 定时帧"></a>5.1 定时帧</h2><p>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p><code>CAAnimation</code>最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<h2 id="5-2_NSTimer"><a href="#5-2_NSTimer" class="headerlink" title="5.2 NSTimer"></a>5.2 <code>NSTimer</code></h2><p> iOS上的每个线程都管理了一个<code>NSRunloop</code>，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘</li>
</ul>
<p>当你设置一个<code>NSTimer</code>，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</p>
<p>我们可以通过一些途径来优化：</p>
<ul>
<li>我们可以用<code>CADisplayLink</code>让更新频率严格控制在每次屏幕刷新之后。</li>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的<code>run loop</code>模式，这样就不会被别的事件干扰。</li>
</ul>
<h2 id="5-3_CADisplayLink"><a href="#5-3_CADisplayLink" class="headerlink" title="5.3 CADisplayLink"></a>5.3 <code>CADisplayLink</code></h2><p> <code>CADisplayLink</code>是CoreAnimation提供的另一个类似于<code>NSTimer</code>的类，它总是在屏幕完成一次更新之前启动。</p>
<p>当使用<code>NSTimer</code>的时候，一旦有机会计时器就会开启，但是<code>CADisplayLink</code>却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/23/iOS-Core-Animation-Advanced-Techniques阅读笔记（三）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          iOS Core Animation Advanced Techniques阅读笔记（三）
        
      </div>
    </a>
  
  
    <a href="/2018/07/20/iOS-Core-Animation-Advanced-Techniques阅读笔记（一）/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iOS Core Animation Advanced Techniques阅读笔记（一）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="iOS-Core-Animation-Advanced-Techniques阅读笔记（二）" data-title="iOS Core Animation Advanced Techniques阅读笔记（二）" data-url="http://yoursite.com/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>