<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Daniel Young's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daniel Young's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOS小知识（五）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/28/iOS小知识（五）/" class="article-date">
  	<time datetime="2018-06-28T15:38:48.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/28/iOS小知识（五）/">iOS小知识（五）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001_protocol__u548C_delegate"><a href="#u4E00_u3001_protocol__u548C_delegate" class="headerlink" title="一、 protocol 和 delegate"></a>一、 protocol 和 delegate</h4><p>​    protocol 自己定义，自己实现。遵从该protocol 的ivar，拥有protocol声明的能力。</p>
<p>​    delegate 自己定义，他人实现。自己无法实现某方法时，他人帮你实现。</p>
<h4 id="u4E8C_u3001strong-weak_dance"><a href="#u4E8C_u3001strong-weak_dance" class="headerlink" title="二、strong-weak dance"></a>二、strong-weak dance</h4><p>在block中一开始就执行<code>__strong typeof（weakSelf）strongSelf  =  weakSelf</code>，是为了在block代码执行期间，其他线程 release了weakSelf，不释放weakSelf所指向的对象，只是引用计数-1。但是在block执行之前，weakSelf可能已经释放了，因此，在block中应该先判断strongSelf 是否为nil。避免引起crash。</p>
<h4 id="u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers"><a href="#u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers" class="headerlink" title="三、 Designated Initializers 和 Convenience Initializers"></a>三、 Designated Initializers 和 Convenience Initializers</h4><p>Designated Initializers 可以调super，一般一个类只有一个（且至少有一个），用来完成继承链</p>
<p>Convenience Initializers 不调super，调 self，一个类可以没有</p>
<ul>
<li><p><strong>Rule 1</strong></p>
<p>designated initializer 必须调用其父类的designated initializer</p>
</li>
<li><p><strong>Rule 2</strong></p>
<p>convenience initializer 必须调用本类的initializer方法</p>
</li>
<li><p><strong>Rule 3</strong></p>
<p>convenience initializer 最后必须调用designated initializer</p>
</li>
</ul>
<p><img src="https://docs.swift.org/swift-book/_images/initializerDelegation02_2x.png" alt=""></p>
<h4 id="u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528"><a href="#u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528" class="headerlink" title="四、NSProxy 和 NSObject 方法调用"></a>四、NSProxy 和 NSObject 方法调用</h4><p>​    <strong>NSObejct</strong> </p>
<p>​    1）在本类 method list 中查找selector 。找不到时，沿着继承链查找selector，直到找到为止。若找不到，进入消息派发流程。</p>
<p>​    2）进入消息派发时，本类会调用 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>，其中sel 为selector。在这一步，本类可以使用<code>class_addMethod（）</code> 来动态添加方法处理这个selector，并返回YES表示selector被成功处理。 </p>
<p>​    3）在<code>resolveInstanceMethod:</code> 方法返回NO的情况下，本类会调用</p>
<p><code>- (id)forwardingTargetForSelector:(SEL)sel</code> ，其中sel 为selector。在这一步，本类可以返回一个能够处理该selector的备援对象，表示该备援对象可以处理selector。</p>
<p>​    4）在<code>forwardingTargetForSelector:</code> 方法返回nil的情况下，本类会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code> ，用sel来生成一个NSMethodSignature 对象（携带了selector的参数类型、返回值类型和长度等信息）。在<code>methodSignatureForSelector:</code>的返回值不为nil的情况下，本类调用 <code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，在该方法中，我们可以修改invocation的target，改变selector的receiver。</p>
<p>​    <strong>NSProxy</strong></p>
<p>​    NSProxy对象会直接回调 <code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code></p>
<h4 id="u4E94_u3001UIButton_edgeInset"><a href="#u4E94_u3001UIButton_edgeInset" class="headerlink" title="五、UIButton edgeInset"></a>五、UIButton edgeInset</h4><p><code>contentEdgeInsets:</code> 表示content相对于button矩形的inset/outset，其insets (top, left, bottom, right) 正值将使button矩形的size变大，负值将缩小size。button可以通过这个insets来决定自身的大小。</p>
<p><code>titleEdgeInsets:</code>  表示titleLabel相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel左移/下移，负值将使titleLabel右移/上移。其中的top/bottom 和 left/right 应互为相反数。需要注意的是：insets是在titleLable.text 进行sizetToFits 之后才设置的，因此，正值的inset可能会使text被截断。</p>
<p><code>imageEdgeInsets:</code>  表示imageView相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel左移/下移，负值将使titleLabel右移/上移。其中的top/bottom 和 left/right 应互为相反数。</p>
<p>`</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（四）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/19/iOS小知识（四）/" class="article-date">
  	<time datetime="2018-06-19T08:02:57.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/19/iOS小知识（四）/">iOS小知识（四）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>contentOffset 表示UIScrollView滚动的位置。（其实就是内容视图左上角与scrollView显示视图左上角的间距值）</p>
<p>contentsize：内容显示的尺寸，包括tableheadview。 cell， tableFootView，而且tableview添加子视图的顶点是contentsize的左上角，但如果子视图的起点为-50，则contentsize自动会向上扩展50.</p>
<p>contentInset：附着内容尺寸，在contentsize的四周</p>
<p>contentOffset.y：已滚动的y值，contentsize顶部到目前屏幕的顶部</p>
</li>
<li><p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。</p>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适</p>
</li>
<li><p><code>removeFromSuperview</code>就是一个视图节点删除的操作，执行这个方法，就等于在树形结构中找到该节点，从树型数据结构中删除该节点及其子节点，而并非只是删除该节点自己。同时，另一个操作就是把该对象从响应者链中移除。removeFromSuperview，子视图只remove一次</p>
</li>
<li><p>new 等于 alloc init ，除了alloc 会分配一块相邻的zone来提升程序处理速度。并且，new 实质上隐形的调用了init，alloc init 可以调用更多的初始化函数。因此，在iOS开发中，人们更加习惯于alloc init。</p>
</li>
<li><p><code>addsubview:</code>，子视图只添加一次。多个superView对同一subView执行<code>addSubview:</code>操作，以最后一次为准</p>
</li>
<li><p>block被成员变量引用后，会被copy一份_NSConcreteMallocBlock类型的block。因此，在weakSelf已经释放的情况下，block还能存在。</p>
</li>
<li><p>图片缩放不止可以用手势，也可以用ScrollView</p>
</li>
<li><p>在OC中，不允许直接修改OC对象的结构体属性的成员</p>
</li>
<li><p>Multiple locks on web thread not allowed! Please file a bug. Crashing now… 是因为在子线程中请求了网络</p>
</li>
<li><p>NSBlockOperation只有其内部是并发执行的，其本身还是同步执行</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/11/iOS小知识（三）/" class="article-date">
  	<time datetime="2018-06-11T04:16:54.000Z" itemprop="datePublished">2018-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/11/iOS小知识（三）/">iOS小知识（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001iOS_u54CD_u5E94_u94FE"><a href="#u4E00_u3001iOS_u54CD_u5E94_u94FE" class="headerlink" title="一、iOS响应链"></a>一、iOS响应链</h4><p>​    <code>pointInside:  withEvent:</code>方法是对于目标view的bounds来说的，因此在<code>hitTest: withEvent:</code>方法中需要先用<code>convertPoint: toView:</code> 方法将point坐标转换到目标view上。</p>
<h4 id="u4E8C_u3001free_brige"><a href="#u4E8C_u3001free_brige" class="headerlink" title="二、free brige"></a>二、free brige</h4><ol>
<li><p><code>__bridge</code>，什么也不做，仅仅是转换。此种情况下：<br>(1). 从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。</p>
<p>(2). 从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。</p>
</li>
<li><p><code>__bridge_retained</code>，转换后自动调用CFRetain，即帮助自动解决上述(1)的情形。</p>
</li>
<li><p><code>__bridge_transfer</code>，转换后自动调用CFRelease，即帮助自动解决上述(2)的情形。</p>
</li>
</ol>
<h4 id="u4E09_u3001__u56FE_u7247_u62C9_u4F38"><a href="#u4E09_u3001__u56FE_u7247_u62C9_u4F38" class="headerlink" title="三、 图片拉伸"></a>三、 图片拉伸</h4><p>​    <code>stretchableImageWithLeftCapWidth：topCapHeight:</code>方法可以创建一个内容可拉伸，而边角不拉伸的图片。需要两个参数，第一个是左边不拉伸区域的宽度，第二个参数是上面不拉伸的高度。</p>
<p><code>注意：可拉伸的范围都是距离leftCapWidth后的1竖排像素，和距离topCapHeight后的1横排像素。</code></p>
<h4 id="u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1"><a href="#u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1" class="headerlink" title="四、 tableView: heightForRowAtIndexPath:和tableView: cellForRowAtIndexPath调用顺序的变迁"></a>四、 <code>tableView: heightForRowAtIndexPath:</code>和<code>tableView: cellForRowAtIndexPath</code>调用顺序的变迁</h4><p><strong>iOS  7及之前: </strong></p>
<p> 先依次调一遍heightForRow方法再依次调一遍cellForRow方法，在调cellForRow方法的时候并不会再调一次对应的heightForRow方法。如果我们实现了<code>tableView: estimatedHeightForRowAtIndexPath:</code>给了系统估计高度，那么上述两个方法的执行顺序就会颠倒。并且给定估计高度对于TableView的性能方面也提示不少。</p>
<p><strong>iOS 8  ：</strong></p>
<p>先依次调heightForRow（如果行数超过屏幕依次调用两次，如果行数很少，没有超过屏幕，只依次调用一次），之后每调一次cellForRow的时候又调一次对应的heightForRow方法。</p>
<p><strong>iOS 9和iOS 10:</strong></p>
<p>heightForRow方法会先调用三次，然后每调用一次cellForRow的时候再调用一次对应的heightForRow。</p>
<p><strong>iOS 11 ：</strong></p>
<p> 先row = 0调用一次 cellForRow，然后一次heightForRow.然后再是row =1 ,依次类推。</p>
<h4 id="u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak"><a href="#u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak" class="headerlink" title="五、在Xib中，拖出来的控件为weak"></a>五、在Xib中，拖出来的控件为weak</h4><p>​    IBOutlet的属性一般可以设为weak是因为它已经被IBOutlet.superView引用了，除非IBOutlet.superView被释放，否则IBOutlet的属性也不会被释放。另外IBOutlet属性的生命周期和IBOutlet.superView应该是一致的，所以IBOutlet属性一般设为weak。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/06/iOS小知识（二）/" class="article-date">
  	<time datetime="2018-06-06T04:17:11.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/iOS小知识（二）/">iOS小知识（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001Xcode_u96C6_u6210reveal"><a href="#u4E00_u3001Xcode_u96C6_u6210reveal" class="headerlink" title="一、Xcode集成reveal"></a>一、Xcode集成reveal</h4><ol>
<li>首先打开Terminal，输入<code>vim ~/.lldbinit</code>创建一个名为.lldbinit的文件，然后将如下内容输入到该文件中：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command <span class="keyword">alias</span> reveal_load_sim expr (void*)dlopen(<span class="string">"/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib"</span>, <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_load_dev expr (void*)dlopen([(<span class="constant">NSString</span>*)[(<span class="constant">NSBundle</span>*)[<span class="constant">NSBundle</span> mainBundle]               <span class="symbol">pathForResource:</span>@<span class="string">"libReveal"</span> <span class="symbol">ofType:</span>@<span class="string">"dylib"</span>] <span class="symbol">cStringUsingEncoding:</span><span class="number">0</span>    x4], <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_start expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]           <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStart"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br><span class="line">command <span class="keyword">alias</span> reveal_stop expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]            <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStop"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br></pre></td></tr></table></figure>
<p>​    该步骤其实是为lldb设置了4个别名，为了后续方便操作，这4个别名意义如下：</p>
<p>​    <code>reveal_load_sim</code> 为模拟器加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_load_dev</code> 为真机加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_start</code> 启动<strong>reveal</strong>调试功能</p>
<p>​    <code>reveal_stop</code> 结束<strong>reveal</strong>调试功能</p>
<ol>
<li><p>在AppDelegate类的<code>application:didFinishLaunchingWithOptions:</code>方法中，作如下3步操作：</p>
<p>1) 点击该方法左边的行号区域，增加一个断点，之后右击该断点，选择“Edit Breakpoint”。</p>
<p>2) 点击”Action”项边右的”Add Action”,然后输入“reveal_load_sim”</p>
<p>3) 勾选上Options上的”Automatically continue after evaluating”选项。</p>
</li>
</ol>
<h4 id="u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B"><a href="#u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B" class="headerlink" title="二、Charles 使用教程"></a>二、Charles 使用教程</h4><ol>
<li><p>抓包Https</p>
<p>1) 安装Charles 根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate</p>
<p>2) iOS Simulator 安装根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate in iOS Simulators</p>
<p>3) 设置SSL Host / Port</p>
<p>​    路径： proxy -&gt; SSL Proxying setting -&gt;SSL Proxying</p>
<p>Host/Port 设为*</p>
<p>4) 重启charles</p>
<ol>
<li><h4 id="u5F31_u7F51_u6D4B_u8BD5"><a href="#u5F31_u7F51_u6D4B_u8BD5" class="headerlink" title="弱网测试"></a>弱网测试</h4></li>
</ol>
<p>1) 设置throttle settings</p>
<p>2) 路径： proxy -&gt; throttle settings</p>
<p>3) 根据所需网络环境 Throttle preset 选择弱网环境目标：2G或者3G</p>
</li>
</ol>
<h4 id="u4E09_u3001_u771F_u673Acrash_u5206_u6790"><a href="#u4E09_u3001_u771F_u673Acrash_u5206_u6790" class="headerlink" title="三、真机crash分析"></a>三、真机crash分析</h4><ol>
<li><p>准备好 .crash 文件及.crash 文件所对应的 .dSYM 文件，新建crash文件夹</p>
</li>
<li><p>找到symbolicatecrash路径</p>
<p><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p>
<p>将symbolicatecrash文件复制到crash文件夹</p>
</li>
<li><p>配置developer_dir，cd到crash文件夹</p>
<p><code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></p>
</li>
<li><p>解析crash文件symbolicatecrash</p>
<p><code>./symbolicatecrash /Users/用户名/Desktop/crash/文件名.crash /Users/用户名/Desktop/crash/xxxx（dSYM文件名字）.dSYM &gt; Control_symbol.txt</code></p>
</li>
</ol>
<h4 id="u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5"><a href="#u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5" class="headerlink" title="四、Xcode 断点调试"></a>四、Xcode 断点调试</h4><ol>
<li><p>Exception Breakpoint（异常断点）</p>
<p>当遇到错误，Debug程序会自动定位到栈底信息，即跳到出错代码所在行</p>
</li>
<li><p>Symbolic BreakPoint（符号断点）</p>
<p>根据symbol定位。如 -[XXViewController viewDidLoad]，当 XXViewController 调用 viewDidLoad 时，进行打断。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/01/iOS小知识（一）/" class="article-date">
  	<time datetime="2018-06-01T04:43:22.000Z" itemprop="datePublished">2018-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/01/iOS小知识（一）/">iOS小知识（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>创建 NSDateFormatter，性能较低，使用时应该使用单例，不要每次使用的时候都重新创建。</li>
<li>在 layoutSubviews 中，绝对不能调用setNeedLayout（死循环)，算高方法应该在sizeThatFits中</li>
<li>iPhone SE，iPhone 6 及以下机型都是 @2x，iPhone 6P及以上都是@3x</li>
<li>UIScrollView带有一个 contentInsetAdjustmentBehavior属性，特别是在webView中进行iPhone X 适配的时候，要将其设置为UIScrollViewContentInsetAdjustmentNever</li>
<li><p>iOS7之后，UIScrollView增加了keyboardDismissMode属性，可以设置在scrollView滑动的时候，将键盘关闭。</p>
</li>
<li><p>UIWebView可以跟据链接的来源UIWebViewNavigationType对其操作。</p>
</li>
<li>Runloop 对象是利用字典来进行存储， Key(thread) – Value(loop)</li>
<li>NSNotificationCenter是一个同步的单例模式，而这个通知中心的对象会一直存在于一个应用的生命周期。</li>
<li>勿滥用通知，每次<code>post</code>一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者，这样导致性能降低。</li>
<li>addObserverForName 会生成一个匿名对象，需要remove。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-github-搭建博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/29/hexo-github-搭建博客/" class="article-date">
  	<time datetime="2018-05-29T11:10:47.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/hexo-github-搭建博客/">hexo + github 搭建博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前mac坏了，加上毕业的事情。一直没对blog进行更新，本来以为毕业之后就会有时间来做这事了，可是懒啊Orz……这段时间终于想起这事儿了，但是电脑换了之后，导致重新搭了一次blog，于是重新梳理了一下搭建的过程。</p>
<h4 id="1-_u5B89_u88C5Node-js"><a href="#1-_u5B89_u88C5Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h4><p>​    直接在<a href="https://nodejs.org/en/" target="_blank" rel="external">Node官网</a>下载最新安装包就行了</p>
<h4 id="2-_u5B89_u88C5hexo"><a href="#2-_u5B89_u88C5hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h4><p>​    因为mac本身自带了git，直接在命令行中执行下列命令就好了</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo	/<span class="regexp">/sudo:系统员指令，需输入电脑密码  -g:全局安装</span></span><br></pre></td></tr></table></figure>
<h4 id="3-_u521D_u59CB_u5316"><a href="#3-_u521D_u59CB_u5316" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>​    cd 到安装目录下，执行hexo初始化命令</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> blog	<span class="comment">//blog为创建的hexo安装文件夹</span></span><br></pre></td></tr></table></figure>
<p>​    此时，在blog文件夹中会生成建站所需的全部文件。在blog目录下，安装hexo</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo -<span class="keyword">g</span></span></span><br></pre></td></tr></table></figure>
<p>​    这样，我们就搭建好了本地的blog。可以试试使用如下指令，生成本地blog。在浏览器中输入localhost:4000就可以看到我们的第一个blog了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">s</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_u90E8_u7F72_u5230github"><a href="#4-_u90E8_u7F72_u5230github" class="headerlink" title="4.部署到github"></a>4.部署到github</h4><p>​    申请一个github账号，然后创建一个新的github仓库 userName.github.io</p>
<p>​    然后在_config.yml进行配置，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/userName/userName.github.io.git	//userName你的用户名</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>​    配置好之后，在命令行中执行</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span> -<span class="literal">d</span></span><br></pre></td></tr></table></figure>
<p>​    这样，就将你的blog部署到github上了。</p>
<h4 id="5-_u57DF_u540D_u7ED1_u5B9A"><a href="#5-_u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="5.域名绑定"></a>5.域名绑定</h4><p>​    一般推荐在<a href="https://link.jianshu.com/?t=https://www.godaddy.com" target="_blank" rel="external">goDaddy</a>上购买域名，因为不需要备案……但是图方便的话，可以在阿里万网上买，也比较便宜一点。</p>
<ol>
<li>在blog目录下的CNAME文件中，添加域名信息。然后hexo g -d，部署到github上</li>
</ol>
<ol>
<li><p>注册DNSPod，添加域名。添加CNAME记录为 username.github.io，添加@记录为 username.github.io对应的IP地址</p>
</li>
<li><p>在goDaddy网站上，绑定DNSPod的解析</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1<span class="class">.dnspod</span><span class="class">.net</span>.</span><br><span class="line">f1g1ns2<span class="class">.dnspod</span><span class="class">.net</span>.</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<p>这样，48小时之内，输入我们的域名，就能看到blog上线咯</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Core-Image实战之二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/09/Core-Image实战之二/" class="article-date">
  	<time datetime="2016-11-09T01:15:24.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/Core-Image实战之二/">Core Image实战之二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>距离上一篇关于Core Image的文章已经过去4个月了……因为实习和找工作的原因，blog一直没有更新，实在是懒癌晚期。目前找工作早已告一段落，又稍稍休息了一段时间，现在也算有时间再弄弄blog吧。闲话不多说，上干货。</p>
<h2 id="CIFilter"><a href="#CIFilter" class="headerlink" title="CIFilter"></a>CIFilter</h2><p>Apple官方一共提供了14个大类的filter，具体如下：</p>
<ol>
<li>CICategoryBlur<br> 模糊滤镜，提供了高斯模糊，运动模糊等一系列的模糊效果。</li>
<li>CICategoryColorAdjustment<br> 色调调整，提供了色温，色相，曝光等一系列的调整效果。</li>
<li>CICategoryColorEffect<br> 色彩滤镜，提供了鲜艳，黑白等一系列的色彩滤镜。</li>
<li>CICategoryCompositeOperation<br> 混合效果，提供了图片混合的操作。</li>
<li>CICategoryDistortionEffect<br> 变形效果，提供了圆形扭曲，矩形扭曲等一系列变形。</li>
<li>CICategoryGenerator<br> 图像生成器，提供了二维码，条形码等图像的生成。</li>
<li>CICategoryGeometryAdjustment<br> 位置调整，提供了旋转，剪切等位置变换效果。</li>
<li>CICategoryGradient<br> 渐变效果，提供了高斯渐变，线性渐变等渐变图像的生成。</li>
<li>CICategoryHalftoneEffect<br> 网板效果，提供了雪花屏，线性屏等网板效果。</li>
<li>CICategoryReduction<br>降低效果，将图像的RGB值显示在图像中。</li>
<li>CICategorySharpen<br>锐化效果，提供了整体锐化和部分锐化效果。</li>
<li>CICategoryStylize<br>风格化效果，提供了发光，像素化等一系列的风格化滤镜效果。</li>
<li>CICategoryTileEffect<br>拼接效果，提供了万花筒，多边形拼接等一系列拼接效果。</li>
<li>CICategoryTransition<br>转屏效果，提供了淡入淡出，卷页等一系列的转屏效果。</li>
</ol>
<h3 id="CIFilter_u4E2D_u7684_u5751"><a href="#CIFilter_u4E2D_u7684_u5751" class="headerlink" title="CIFilter中的坑"></a>CIFilter中的坑</h3><p>由于CIFilter是基于KVO的编码方式，实际上的使用还是比较难用的。而且再加上像NSData这种不看官方文档完全无法知道里面data包含什么参数的类型，最坑的是官方文档中关于这类参数的介绍也是很少，对于新手来说，完全找不到北。只有在stackOverFlow中才有一些关于NSData里面到底应该传入什么数据的讨论。<br>举个例子，CIColorCube这个filter中有三个输入参数：</p>
<ol>
<li>inputImage，输入的图像，这个很好理解；</li>
<li>inputCubeDimension，输入的cube维度，第一次看完全懵逼，下面有介绍；</li>
<li>inputCubeData，cube的纹理，用作色彩查找表（CLUT）。<br>inputCubeDimension的类型是NSNumber，看起来好想不复杂，但是，这个NSNumber的值需要和CLUT的维度一致。如下图：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/LUT.png" alt="LUT图"><br>该图一共有 8 * 8 = 64个维度，因此，inputCubeDimension的值为64。</li>
</ol>
<p>inputCubeData的类型的NSData，看类型名完全不知道这个参数应该输入什么，而Apple官方文档中写的是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate and opulate color cube table</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">float</span> *cubeData = (<span class="keyword">float</span> *)malloc(size * size * size * <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; size; b++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; size; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; size; r ++) &#123;</span><br><span class="line">            cubeData[b][g][r][<span class="number">0</span>] = &lt;<span class="preprocessor"># output R value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">1</span>] = &lt;<span class="preprocessor"># output G value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">2</span>] = &lt;<span class="preprocessor"># output B value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">3</span>] = &lt;<span class="preprocessor"># output A value #&gt;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Put the table in a data object and create the filter</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytesNoCopy:cubeData</span><br><span class="line">                                    length:cubeDataSize</span><br><span class="line">                              freeWhenDone:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">CIFilter</span> *colorCube = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIColorCube"</span></span><br><span class="line">                           withInputParameters:@&#123;</span><br><span class="line">    <span class="string">@"inputCubeDimension"</span>: @(size),</span><br><span class="line">    <span class="string">@"inputCubeData"</span>: data,</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>在苹果的代码中，data成为了一个RGB的输入，而事实上该参数应该由一张LUT图来转换，根据stackOverFlow中关于CIColorCube的讨论，我写下了如下的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">NSData</span> *) colorCubeDataFromLUT:(<span class="built_in">UIImage</span> *)image withDimension:(<span class="built_in">NSInteger</span>)dimension</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> kDimension = dimension;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!image) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> width = <span class="built_in">CGImageGetWidth</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> height = <span class="built_in">CGImageGetHeight</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> rowNum = height / kDimension;</span><br><span class="line">    <span class="built_in">NSInteger</span> columnNum = width / kDimension;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((width % kDimension != <span class="number">0</span>) || (height % kDimension != <span class="number">0</span>) || (rowNum * columnNum != kDimension)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Invalid colorLUT"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> *bitmap = [<span class="keyword">self</span> createRGBABitmapFromImage:image<span class="variable">.CGImage</span>];</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Convert bitmap data written in row,column order to cube data written in x:r, y:g, z:b representation where z varies &gt; y varies &gt; x.</span></span><br><span class="line">    <span class="built_in">NSInteger</span> size = kDimension * kDimension * kDimension * <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">float</span> *data = malloc(size);</span><br><span class="line">    <span class="keyword">int</span> bitmapOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt;  rowNum; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kDimension; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = z;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; columnNum; col++) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> dataOffset = (z * kDimension * kDimension + y * kDimension) * <span class="number">4</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> divider = <span class="number">255.0</span>;</span><br><span class="line">                vDSP_vsdiv(&amp;bitmap[bitmapOffset], <span class="number">1</span>, &amp;divider, &amp;data[dataOffset], <span class="number">1</span>, kDimension * <span class="number">4</span>); <span class="comment">// Vector scalar divide; single precision. Divides bitmap values by 255.0 and puts them in data, processes each column (kDimension * 4 values) at once.</span></span><br><span class="line">                </span><br><span class="line">                bitmapOffset += kDimension * <span class="number">4</span>; <span class="comment">// shift bitmap offset to the next set of values, each values vector has (kDimension * 4) values.</span></span><br><span class="line">                z++;</span><br><span class="line">            &#125;</span><br><span class="line">            z = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        z += columnNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:data length:size freeWhenDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span> *)createRGBABitmapFromImage:(<span class="built_in">CGImageRef</span>)image &#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bitmap;</span><br><span class="line">    <span class="built_in">NSInteger</span> bitmapSize;</span><br><span class="line">    <span class="built_in">NSInteger</span> bytesPerRow;</span><br><span class="line">    </span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(image);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(image);</span><br><span class="line">    </span><br><span class="line">    bytesPerRow   = (width * <span class="number">4</span>);</span><br><span class="line">    bitmapSize     = (bytesPerRow * height);</span><br><span class="line">    </span><br><span class="line">    bitmap = malloc( bitmapSize );</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">if</span> (colorSpace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(bitmap);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context = <span class="built_in">CGBitmapContextCreate</span> (bitmap,</span><br><span class="line">                                     width,</span><br><span class="line">                                     height,</span><br><span class="line">                                     <span class="number">8</span>,</span><br><span class="line">                                     bytesPerRow,</span><br><span class="line">                                     colorSpace,</span><br><span class="line">                                     (<span class="built_in">CGBitmapInfo</span>)k<span class="built_in">CGImageAlphaPremultipliedLast</span>);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>( colorSpace );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free (bitmap);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), image);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> *convertedBitmap = malloc(bitmapSize * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    vDSP_vfltu8(bitmap, <span class="number">1</span>, convertedBitmap, <span class="number">1</span>, bitmapSize); <span class="comment">// Converts an array of unsigned 8-bit integers to single-precision floating-point values.</span></span><br><span class="line">    free(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> convertedBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，就将inputCubeData的输入转为UIImage。</p>
<h2 id="Custom_Filter"><a href="#Custom_Filter" class="headerlink" title="Custom Filter"></a>Custom Filter</h2><p>和GPUImage一样，Core Image也支持自定义滤镜，但是需要注意的是：Core Image自定义滤镜采用The Core Image kernel language，大致和OpenGl一样，但是并不能无缝链接。比如不支持OpenGl shading的预处理以及mat2, mat3, mat4, struct, arrays。</p>
<h3 id="u4E00_u4E2A_u7B80_u5355_u7684_u81EA_u5B9A_u4E49_u6EE4_u955C"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u81EA_u5B9A_u4E49_u6EE4_u955C" class="headerlink" title="一个简单的自定义滤镜"></a>一个简单的自定义滤镜</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 YQMirrorVer(sampler image)</span><br><span class="line">&#123;</span><br><span class="line">    vec2 uv = samplerCoord(image);</span><br><span class="line">    uv = floor(uv*<span class="number">50.0</span>)/<span class="number">50.0</span>;</span><br><span class="line">    <span class="keyword">return</span> sample(image,uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们可以定义一个简单的马赛克滤镜shader，接着我们还需要定义一个类继承于CIFilter。其m文件如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CIKernel</span> *)YQMosaic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CIKernel</span> *kernelPrewitt = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBundle</span>    *bundle       = [<span class="built_in">NSBundle</span> bundleForClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"YQMosaic"</span>)];</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    <span class="built_in">NSError</span>     *error        = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span>    *code         = [<span class="built_in">NSString</span> stringWithContentsOfFile:[bundle pathForResource:<span class="string">@"YQMosaic"</span> ofType:<span class="string">@"cikernel"</span>] encoding:encoding error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    kernelPrewitt             = [<span class="built_in">CIKernel</span> kernelWithString:code];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernelPrewitt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CIImage</span> *)outputImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CIImage</span> *result = <span class="keyword">self</span><span class="variable">.inputImage</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> YQMosaic] applyWithExtent:result<span class="variable">.extent</span></span><br><span class="line">                                roiCallback:^<span class="built_in">CGRect</span>(<span class="keyword">int</span> index, <span class="built_in">CGRect</span> rect) &#123;</span><br><span class="line">                                         <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(result<span class="variable">.extent</span>), <span class="built_in">CGRectGetHeight</span>(result<span class="variable">.extent</span>));</span><br><span class="line">                                     &#125;</span><br><span class="line">                                  arguments:@[result]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就自定义了一个我们自己的滤镜，可以直接像CIFilter一样使用。</p>
<p>参考资料</p>
<p>1.<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_blank" rel="external">Core Image Filter Reference</a> Apple<br>2.<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397" target="_blank" rel="external">Core Image Kernel Language Reference</a> Apple<br>3.<a href="https://github.com/FlexMonkey/Filterpedia" target="_blank" rel="external">Filterpedia</a> FlexMonkey </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GPUImage实战" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/07/GPUImage实战/" class="article-date">
  	<time datetime="2016-07-07T04:21:38.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/GPUImage实战/">Core Image实战之一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在公司做项目要用到Core Image，而之前对于CoreImage和GPUImage都基本没有了解过。于是趁着项目的驱动，做了一个小Demo。</p>
<h2 id="Core_Image_u7B80_u4ECB"><a href="#Core_Image_u7B80_u4ECB" class="headerlink" title="Core Image简介"></a>Core Image简介</h2><blockquote>
<p>Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.</p>
</blockquote>
<p>这是苹果官方文档对于Core Image的介绍，大致意思是：Core Image是一种为静态图像和video图像提供处理和分析的技术，它可以使用GPU/CPU的方式对图像进行处理。Core Image提供了简洁的API给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解OpenGL、OpenGL ES甚至是GCD的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。废话这么多，苹果就想告诉我们一件事：所有的底层细节他都帮你做好了，你只需要调用API就行了。</p>
<h2 id="u6EE4_u955C_u4E0E_u6EE4_u955C_u94FE"><a href="#u6EE4_u955C_u4E0E_u6EE4_u955C_u94FE" class="headerlink" title="滤镜与滤镜链"></a>滤镜与滤镜链</h2><p>一个滤镜是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。<br>一个滤镜图表是一个链接在一起的滤镜网络 (无回路有向图)，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。<br>Core Image的实现可以参考下面的图：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-16%20%E4%B8%8B%E5%8D%885.18.40.png" alt=""><br>每个图片对象经过滤镜后作为下一个滤镜的输入（滤镜链），或者直接输出（单个滤镜）。</p>
<h2 id="Core_Image_u2019s_API"><a href="#Core_Image_u2019s_API" class="headerlink" title="Core Image’s API"></a>Core Image’s API</h2><p>Core Image的API主要就是三类：CIImage表示输入的图片；CIFilter表示经过的滤镜；CIContext表示上下文，可以从其中取得图片的信息。</p>
<ul>
<li><p>CIImage<br>保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。一般我们输入的都是UIImage，可以使用：imageWithCGImage:类方法获取CIImage。</p>
</li>
<li><p>CIFilter<br>滤镜类，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</p>
</li>
<li><p>CIContext<br>上下文类，如CoreGraphics以及CoreData中的上下文用于处理绘制渲染以及处理托管对象一样，CoreImage的上下文也是实现对图像处理的具体对象。<br>这里需要注意的是在Context创建的时候，我们需要给它设定为是基于GPU还是CPU。<br>基于GPU的话，处理速度更快，因为利用了GPU硬件的并行优势。但是GPU受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用CPU，因为当app切换到后台状态时GPU处理会被打断。</p>
</li>
</ul>
<h3 id="u4F7F_u7528_u6B65_u594F"><a href="#u4F7F_u7528_u6B65_u594F" class="headerlink" title="使用步奏"></a>使用步奏</h3><ol>
<li><p>创建图像上下文 CIContext</p>
</li>
<li><p>创建滤镜 CIFilter</p>
</li>
<li><p>创建过滤原图片 CIImage</p>
</li>
<li><p>调用 CIFilter 的 setValue:forKey:方法为滤镜指定源图片</p>
</li>
<li><p>设置滤镜参数【可选】</p>
</li>
<li><p>取得输出图片显示或保存</p>
</li>
</ol>
<p>具体实现可以参考最下面的Demo。</p>
<h2 id="GPUImage_u7B80_u4ECB"><a href="#GPUImage_u7B80_u4ECB" class="headerlink" title="GPUImage简介"></a>GPUImage简介</h2><blockquote>
<p>The GPUImage framework is a BSD-licensed iOS library that lets you apply GPU-accelerated filters and other effects to images, live camera video, and movies. In comparison to Core Image (part of iOS 5.0), GPUImage allows you to write your own custom filters, supports deployment to iOS 4.0, and has a simpler interface. However, it currently lacks some of the more advanced features of Core Image, such as facial detection.</p>
</blockquote>
<p>这是Brad Larson的Github对GPUImage做出的介绍，大致就是GPUImage以BSD协议放出，能够在图像、实时摄像头影像和视频上使用GPU加速的滤镜和其他效果。但是他相比于Core Image还是有不足的地方，就是他不支持面部检测。<br>GPUImage的使用和Core Image非常类似，也是将前一个滤镜的输出作为下一个滤镜的输入来实现滤镜链。</p>
<h2 id="GPUImage_u7684_u4F7F_u7528"><a href="#GPUImage_u7684_u4F7F_u7528" class="headerlink" title="GPUImage的使用"></a>GPUImage的使用</h2><p>Brad Larson在GPUImage的github上给出了使用方法，这里贴出来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *inputImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Lambeau.jpg"</span>];</span><br><span class="line"></span><br><span class="line">GP<span class="built_in">UImagePicture</span> *stillImageSource = [[GP<span class="built_in">UImagePicture</span> alloc] initWithImage:inputImage];</span><br><span class="line">GP<span class="built_in">UImageSepiaFilter</span> *stillImageFilter = [[GP<span class="built_in">UImageSepiaFilter</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[stillImageSource addTarget:stillImageFilter];</span><br><span class="line">[stillImageFilter useNextFrameForImageCapture];</span><br><span class="line">[stillImageSource processImage];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *currentFilteredVideoFrame = [stillImageFilter imageFromCurrentFramebuffer];</span><br></pre></td></tr></table></figure></p>
<p>如果只经过一个滤镜直接输出的话，可以简化为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GP<span class="built_in">UImageSepiaFilter</span> *stillImageFilter2 = [[GP<span class="built_in">UImageSepiaFilter</span> alloc] init];</span><br><span class="line"><span class="built_in">UIImage</span> *quickFilteredImage = [stillImageFilter2 imageByFilteringImage:inputImage];</span><br></pre></td></tr></table></figure>
<h2 id="u4E00_u4E2A_u7B80_u5355_u7684_u6EE4_u955CAPP"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u6EE4_u955CAPP" class="headerlink" title="一个简单的滤镜APP"></a>一个简单的滤镜APP</h2><p>前段时间用GPUImage做过一次，最近又用Core Image重构了一遍，两者的使用实际上差不了太多，下面是实际效果和代码。</p>
<p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/coreimage.gif?imageView/2/w/300/q/90" alt=""></p>
<p>代码Demo<a href="https://github.com/oushiyq/YQCoreImageDemo" target="_blank" rel="external">在这</a> </p>
<p>参考资料</p>
<p>1.<a href="https://objccn.io/issue-21-6/" target="_blank" rel="external">Core Image 介绍</a> ObjC中国<br>2.<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html" target="_blank" rel="external">About Core Image</a> Apple<br>3.<a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a> BradLarson </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-APP是如何启动的-理解UIApplication" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/26/APP是如何启动的-理解UIApplication/" class="article-date">
  	<time datetime="2016-05-26T11:49:57.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/APP是如何启动的-理解UIApplication/">理解UIApplication</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>一直都知道UIApplication对象是APP的单例，表示运行的APP。但从来都是只知道如何用，而却没有深入了解一下这个对象。最近看了一个关于UIApplication的视频，于是便写了这样一篇文章，算是自己的对整个视频的总结吧。</p>
<h2 id="UIApplication_u7B80_u4ECB"><a href="#UIApplication_u7B80_u4ECB" class="headerlink" title="UIApplication简介"></a>UIApplication简介</h2><p>UIApplication对象是应用程序的象征，每一个应用都有自己的UIApplication对象，而且是单例的。通过[UIApplication sharedApplication]可以获得这个单例对象。一个iOS程序启动后创建的第一个对象就是UIApplication对象。利用UIApplication对象，能进行一些应用级别的操作。比较常见的UIApplication操作有：</p>
<ol>
<li><p>设置APP图标上的小红点，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIApplicationsharedApplication</span>]<span class="variable">.applicationIconBadgeNumber</span> = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置statusBar中联网指示器的可见性，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIApplicationsharedApplication</span>]<span class="variable">.networkActivityIndicatorVisible</span> =<span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>openURL：打开其他程序，比如使用Safari打开百度，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APP通过协议头来判断打开程序的类型，如电话『tel』，短信『sns』</span></span><br><span class="line">   [[<span class="built_in">UIApplicationsharedApplication</span>] openURL:<span class="string">@"http://www.baidu.com"</span>]];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="UIApplicationMain"><a href="#UIApplicationMain" class="headerlink" title="UIApplicationMain"></a>UIApplicationMain</h2><p>如同c语言一样，iOS程序的入口也是main函数。在每个我们创建的oc语言的project中，Xcode都会自动生成一个如下的main函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看到，main函数返回一个UIApplicationMain。那么这个UIApplicationMain到底是个什么东西呢？先不急，我们可以看看UIApplicationMain的四个参数分别代表着什么意思，我们可以从苹果的帮助文档中搜到这个：</p>
<p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/QQ20160526-1.png" alt=""><br>简单讲解一下：</p>
<ol>
<li>argc, argv两个参数并没有什么实际意义，只是为了和main函数的argc, argv参数保持一致而已；</li>
<li>principalClassName，表示UIApplication类或者其子类，当为nil时，表示UIApplication类，；</li>
<li>delegateClassName，表示APP的delegate在哪实现。如果principalClassName是UIApplication的子类，那么delegate得遵守子类的协议。在这个delegate中，我们还可以指定APP的rootViewController。<br>通过上面的几个参数，UIApplicationMain函数会根据principalClassName创建UIApplication对象，根据delegateClassName创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性。</li>
</ol>
<p>接着，就开启APP的主循环Runloop，这个我在之前的一篇<a href="http://yangqiweb.com/2016/03/11/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84RunLoop/" target="_blank" rel="external">博客</a>也提到了APP启动会自动生成一个runloop。之后，加载info.plist，根据『Main storyboard file base name』key的value来判断是否有指定加载的main.xib。</p>
<h2 id="UIApplication_u7684delegate"><a href="#UIApplication_u7684delegate" class="headerlink" title="UIApplication的delegate"></a>UIApplication的delegate</h2><p>UIApplication的delegate即是AppDelegate类，我们可以看下Xcode给我们默认提供的几个要我们实现的optical protocol。代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP的Lauch图片加载完后</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//APP退到后台之前</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span></span><br><span class="line">    <span class="comment">// Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//APP进入后台运行</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span></span><br><span class="line">    <span class="comment">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//APP从后台将要进入前台</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//APP从后台进入前台之前</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//APP终止运行</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的protocol，我们可以在APP的生命周期中实现很多功能，比如我们一般用application: didFinishLaunchingWithOptions:来指定进入APP之后的第一个界面。</p>
<h2 id="UIApplication_u4E0EUIWindow"><a href="#UIApplication_u4E0EUIWindow" class="headerlink" title="UIApplication与UIWindow"></a>UIApplication与UIWindow</h2><p>UIApplication的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件到一个合适的处理事件的目标控件。此外，UIApplication实例还维护一个在本应用中打开的window列表（UIWindow实例），这样它就可以接触应用中的任何一个UIView对象。<br>UIWindow是UIView存在的基础，UIView附着在UIWindow之上。UIWindow本身是有优先级的差别的，即windowLevel，系统默认有三个级别，从高到低依次为：UIWindowLevelAlert、UIWindowLevelNormal、UIWindowLevelStatus和UIWindowLevel。但其并不是枚举类型，而是float，因此我们可以自定义不同的UIWindow优先级。<br>另外，UIWindow只有一个keyWindow，如果某个UIWindow内部的文本框不能输入文字，可能是因为这个UIWindow不是keyWindow。</p>
<p>参考资料：<br><a href="http://www.cnblogs.com/pengyingh/articles/2342014.html" target="_blank" rel="external">UIApplication深入研究</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GCD基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/19/GCD基础/" class="article-date">
  	<time datetime="2016-05-19T06:54:55.000Z" itemprop="datePublished">2016-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/19/GCD基础/">GCD基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GCD_u7B80_u4ECB"><a href="#GCD_u7B80_u4ECB" class="headerlink" title="GCD简介"></a>GCD简介</h2><p>线程管理在应用程序中一直是个难点，当我们自己实现线程的同时，还要注意避免死锁、数据竞争……等等一系列的坑。并且我们实现的线程管理也并不一定是高效的，因为通常线程管理用的代码要在系统级实现。<br>而基于XNU实现的GCD刚好满足了我们对线程管理的功能和性能需求，并提供了一系列线程安全的API让我们可以在自己的程序中调用。也就是说，GCD用我们难以置信的简洁API实现了极为复杂繁琐的多线程编程。</p>
<h2 id="Dispatch_Queue"><a href="#Dispatch_Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>Dispatch Queue如同其名称所示，表示的是『执行处理的等待对列』。作为iOS开发者我们可以通过dispatch_async函数等API，在block中写入我们想要执行的处理并将其追加到相应的queue中执行处理。<br>Dispatch Queue一共有两种：</p>
<h3 id="1-_Serial_Dispatch_Queue_uFF1A_u4E32_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EA_u5904_u7406_u4E00_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u4E32_u884C_u961F_u5217_u7684_u4EFB_u52A1_u9700_u7B49_u5F85_u524D_u9762_u7684_u4EFB_u52A1_u5904_u7406_u5B8C_u6210_u540E_uFF0C_u624D_u80FD_u6267_u884C_u3002"><a href="#1-_Serial_Dispatch_Queue_uFF1A_u4E32_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EA_u5904_u7406_u4E00_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u4E32_u884C_u961F_u5217_u7684_u4EFB_u52A1_u9700_u7B49_u5F85_u524D_u9762_u7684_u4EFB_u52A1_u5904_u7406_u5B8C_u6210_u540E_uFF0C_u624D_u80FD_u6267_u884C_u3002" class="headerlink" title="1. Serial Dispatch Queue：串行派发队列，一次只处理一个任务，加入串行队列的任务需等待前面的任务处理完成后，才能执行。"></a>1. Serial Dispatch Queue：串行派发队列，一次只处理一个任务，加入串行队列的任务需等待前面的任务处理完成后，才能执行。</h3><p>如果需要创建一个Serial Dispatch Queue，有两种方法：</p>
<ol>
<li><p>使用dispatch_queue_create方法创建，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_queue_create(<span class="string">"com.example.testSerialQueue"</span>, DISPATCH_QUEUE_SERIAL)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dispatch_get_main_queue()获取，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-_Concurrent_Dispatch_Queue_uFF1A_u5E76_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EF_u4EE5_u5904_u7406_u591A_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u5E76_u884C_u961F_u5217_u7684_u4EFB_u52A1_u4E0D_u7528_u7B49_u5F85_u5F53_u524D_u5904_u7406_u7684_u4EFB_u52A1_u7ED3_u675F_u3002"><a href="#2-_Concurrent_Dispatch_Queue_uFF1A_u5E76_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EF_u4EE5_u5904_u7406_u591A_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u5E76_u884C_u961F_u5217_u7684_u4EFB_u52A1_u4E0D_u7528_u7B49_u5F85_u5F53_u524D_u5904_u7406_u7684_u4EFB_u52A1_u7ED3_u675F_u3002" class="headerlink" title="2. Concurrent Dispatch Queue：并行派发队列，一次可以处理多个任务，加入并行队列的任务不用等待当前处理的任务结束。"></a>2. Concurrent Dispatch Queue：并行派发队列，一次可以处理多个任务，加入并行队列的任务不用等待当前处理的任务结束。</h3><ol>
<li><p>使用dispatch_queue_create方法创建，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_queue_create(<span class="string">"com.example.mySerialQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dispatch_get_globe_queue()获取，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(高优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(默认优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(低优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(后台优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Dispatch_Group"><a href="#Dispatch_Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个dispatch_group_t的实例来记下这些不同的任务。<br>代码如下：</p>
<ol>
<li><p>使用dispatch_group_notify</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t myGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block3"</span>);&#125;);</span><br><span class="line">    dispatch_group_notify(myGroup, dispatch_get_main_queue(), ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"done"</span>);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span>    </span><br><span class="line">block2</span><br><span class="line">block1</span><br><span class="line">block3</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用dispatch_group_wait    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t myGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block3"</span>);&#125;);</span><br><span class="line">    dispatch_group_wait(myGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line"><span class="comment">/*输出*/</span>    </span><br><span class="line">block2</span><br><span class="line">block1</span><br><span class="line">block3</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="dispatch_sync_u4E0Edispatch_async"><a href="#dispatch_sync_u4E0Edispatch_async" class="headerlink" title="dispatch_sync与dispatch_async"></a>dispatch_sync与dispatch_async</h2><p>在GCD中，dispatch_sync和dispatch_async是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(someQueue1, ^&#123;</span><br><span class="line">    <span class="comment">// do something 1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// do something 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(someQueue2, ^&#123;</span><br><span class="line">    <span class="comment">// do something 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// do something 4</span></span><br></pre></td></tr></table></figure></p>
<p>对于同步任务，something2一定是在something1完成之后运行；对于异步任务，当运行到dispatch_async（）时，dispatch_async（）会在另一个线程里运行，然后立即执行something 4。待dispatch_async（）执行something3。完成之后，回来原来的线程。<br>因此顺序为1，2，4，3。从这里我们可以看出dispatch_sync与dispatch_async的区别。</p>
<h3 id="u4F7F_u7528dispatch_sync_u7684_u6CE8_u610F_u70B9"><a href="#u4F7F_u7528dispatch_sync_u7684_u6CE8_u610F_u70B9" class="headerlink" title="使用dispatch_sync的注意点"></a>使用dispatch_sync的注意点</h3><p>在dispatch_sync嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁。可以看下面的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> myQueue =</span><br><span class="line">    dispatch_queue_create(<span class="string">"com.testSerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(myQueue, ^&#123;<span class="comment">// block1 begin</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(myQueue, ^&#123;<span class="comment">// block2 begin</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);</span><br><span class="line">        &#125;);<span class="comment">// block2 end</span></span><br><span class="line">    &#125;);<span class="comment">// block1 end</span></span><br><span class="line">    <span class="comment">//输出：block1</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，只有block1被打印出来，而block2始终无法打印，这就是死锁。那么死锁产生的原因是什么呢？<br>因为所有的dispatch queue都是线程安全的，所以在上面代码中的每个block中会加锁，当进入block1时，GCD给block1加锁，直到block1 end时，锁才能解开。而进入block2时，锁还加在block1中。于是block2始终在等待block1 end，而block1又在等待block2 end。两者相互等待对方结束，自己才能结束，这样就进入了死锁。</p>
<h3 id="u4E3A_u4EC0_u4E48_u9700_u8981dispatch_sync"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981dispatch_sync" class="headerlink" title="为什么需要dispatch_sync"></a>为什么需要dispatch_sync</h3><p>一开始接触GCD的时候，我一直不明白为什么要有dispatch_sync。因为dispatch_sync不像dispatch_async一样能够借着异步能够带来用户体验上的提升，把一些需要下载的任务丢到从线程，当下载完毕之后再调入主线程。<br>在下面一节，用GCD保护property时，getter方法就是用的dispatch_sync。因为我们不会希望当值还没有赋给实例变量时，就已经return了。</p>
<h2 id="u4F7F_u7528Serial_Dispatch_Queue_u548Cdispatch_barrier_async_u4FDD_u62A4property"><a href="#u4F7F_u7528Serial_Dispatch_Queue_u548Cdispatch_barrier_async_u4FDD_u62A4property" class="headerlink" title="使用Serial Dispatch Queue和dispatch_barrier_async保护property"></a>使用Serial Dispatch Queue和dispatch_barrier_async保护property</h2><p>setter和getter方法是在程序中经常需要用到的方法，是否可以使用GCD来加快他们的执行速度呢？答案肯定是有的，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line">	</span><br><span class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// getter方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为setter方法不需要返回，所以可以采用异步的方式来执行。而barrier只能保证『写操作』不被同一个队列中的其他任务干扰，但无法保证不被其他队列中的任务干扰。因此getter方法需要用同步的方法来保证和setter在同一队列中。</p>
<h2 id="u4F7F_u7528dispatch_once_u6765_u6267_u884C_u53EA_u9700_u8FD0_u884C_u4E00_u6B21_u7684_u7EBF_u7A0B_u5B89_u5168_u4EE3_u7801"><a href="#u4F7F_u7528dispatch_once_u6765_u6267_u884C_u53EA_u9700_u8FD0_u884C_u4E00_u6B21_u7684_u7EBF_u7A0B_u5B89_u5168_u4EE3_u7801" class="headerlink" title="使用dispatch_once来执行只需运行一次的线程安全代码"></a>使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>单例模式（singleton）对任何语言的开发者而言都不陌生，常见的实现方式为：在类编写名为sharedInstance的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。<br>考虑线程安全和性能的情况下，单例模式可以这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> TestClass *sharedInstance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;	</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以选择GCD来实现单列模式，是因为使用disptch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的token，所以token要声明成static。把该变量定义在static作用域中，可以保证编译器在每次执行sharedInstance方法时都会复用这个变量，而不会创建新变量。<br>此外，dispatch_once更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用“原子访问”（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。</p>
<ol>
<li>《Objective-C高级编程》Kazuki Sakamoto，Tomohiko Furumoto </li>
<li>《Effective Objective-C 2.0》 Matt Galloway</li>
<li><a href="http://www.cocoachina.com/industry/20140428/8248.html" target="_blank" rel="external">GCD深入理解(一)</a></li>
<li><a href="http://www.cocoachina.com/industry/20140515/8433.html" target="_blank" rel="external">GCD深入理解(二)</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>