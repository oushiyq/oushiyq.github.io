<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Daniel Young's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daniel Young's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-GCD基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/19/GCD基础/" class="article-date">
  	<time datetime="2016-05-19T06:54:55.000Z" itemprop="datePublished">2016-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/19/GCD基础/">GCD基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GCD_u7B80_u4ECB"><a href="#GCD_u7B80_u4ECB" class="headerlink" title="GCD简介"></a>GCD简介</h2><p>线程管理在应用程序中一直是个难点，当我们自己实现线程的同时，还要注意避免死锁、数据竞争……等等一系列的坑。并且我们实现的线程管理也并不一定是高效的，因为通常线程管理用的代码要在系统级实现。<br>而基于XNU实现的GCD刚好满足了我们对线程管理的功能和性能需求，并提供了一系列线程安全的API让我们可以在自己的程序中调用。也就是说，GCD用我们难以置信的简洁API实现了极为复杂繁琐的多线程编程。</p>
<h2 id="Dispatch_Queue"><a href="#Dispatch_Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>Dispatch Queue如同其名称所示，表示的是『执行处理的等待对列』。作为iOS开发者我们可以通过dispatch_async函数等API，在block中写入我们想要执行的处理并将其追加到相应的queue中执行处理。<br>Dispatch Queue一共有两种：</p>
<h3 id="1-_Serial_Dispatch_Queue_uFF1A_u4E32_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EA_u5904_u7406_u4E00_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u4E32_u884C_u961F_u5217_u7684_u4EFB_u52A1_u9700_u7B49_u5F85_u524D_u9762_u7684_u4EFB_u52A1_u5904_u7406_u5B8C_u6210_u540E_uFF0C_u624D_u80FD_u6267_u884C_u3002"><a href="#1-_Serial_Dispatch_Queue_uFF1A_u4E32_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EA_u5904_u7406_u4E00_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u4E32_u884C_u961F_u5217_u7684_u4EFB_u52A1_u9700_u7B49_u5F85_u524D_u9762_u7684_u4EFB_u52A1_u5904_u7406_u5B8C_u6210_u540E_uFF0C_u624D_u80FD_u6267_u884C_u3002" class="headerlink" title="1. Serial Dispatch Queue：串行派发队列，一次只处理一个任务，加入串行队列的任务需等待前面的任务处理完成后，才能执行。"></a>1. Serial Dispatch Queue：串行派发队列，一次只处理一个任务，加入串行队列的任务需等待前面的任务处理完成后，才能执行。</h3><p>如果需要创建一个Serial Dispatch Queue，有两种方法：</p>
<ol>
<li><p>使用dispatch_queue_create方法创建，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_queue_create(<span class="string">"com.example.testSerialQueue"</span>, DISPATCH_QUEUE_SERIAL)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dispatch_get_main_queue()获取，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-_Concurrent_Dispatch_Queue_uFF1A_u5E76_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EF_u4EE5_u5904_u7406_u591A_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u5E76_u884C_u961F_u5217_u7684_u4EFB_u52A1_u4E0D_u7528_u7B49_u5F85_u5F53_u524D_u5904_u7406_u7684_u4EFB_u52A1_u7ED3_u675F_u3002"><a href="#2-_Concurrent_Dispatch_Queue_uFF1A_u5E76_u884C_u6D3E_u53D1_u961F_u5217_uFF0C_u4E00_u6B21_u53EF_u4EE5_u5904_u7406_u591A_u4E2A_u4EFB_u52A1_uFF0C_u52A0_u5165_u5E76_u884C_u961F_u5217_u7684_u4EFB_u52A1_u4E0D_u7528_u7B49_u5F85_u5F53_u524D_u5904_u7406_u7684_u4EFB_u52A1_u7ED3_u675F_u3002" class="headerlink" title="2. Concurrent Dispatch Queue：并行派发队列，一次可以处理多个任务，加入并行队列的任务不用等待当前处理的任务结束。"></a>2. Concurrent Dispatch Queue：并行派发队列，一次可以处理多个任务，加入并行队列的任务不用等待当前处理的任务结束。</h3><ol>
<li><p>使用dispatch_queue_create方法创建，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_queue_create(<span class="string">"com.example.mySerialQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dispatch_get_globe_queue()获取，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(高优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(默认优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(低优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GLOBAL DISPATCH QUEUE(后台优先级)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Dispatch_Group"><a href="#Dispatch_Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个dispatch_group_t的实例来记下这些不同的任务。<br>代码如下：</p>
<ol>
<li><p>使用dispatch_group_notify</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t myGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block3"</span>);&#125;);</span><br><span class="line">    dispatch_group_notify(myGroup, dispatch_get_main_queue(), ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"done"</span>);&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span>    </span><br><span class="line">block2</span><br><span class="line">block1</span><br><span class="line">block3</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用dispatch_group_wait    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">dispatch_queue_t</span> testSerialQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_t myGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);&#125;);</span><br><span class="line">    dispatch_group_async(myGroup, testSerialQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block3"</span>);&#125;);</span><br><span class="line">    dispatch_group_wait(myGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line"><span class="comment">/*输出*/</span>    </span><br><span class="line">block2</span><br><span class="line">block1</span><br><span class="line">block3</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="dispatch_sync_u4E0Edispatch_async"><a href="#dispatch_sync_u4E0Edispatch_async" class="headerlink" title="dispatch_sync与dispatch_async"></a>dispatch_sync与dispatch_async</h2><p>在GCD中，dispatch_sync和dispatch_async是两个函数，前者用于派发同步任务，后者用于派发异步任务，二者使用格式如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(someQueue1, ^&#123;</span><br><span class="line">    <span class="comment">// do something 1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// do something 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(someQueue2, ^&#123;</span><br><span class="line">    <span class="comment">// do something 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// do something 4</span></span><br></pre></td></tr></table></figure></p>
<p>对于同步任务，something2一定是在something1完成之后运行；对于异步任务，当运行到dispatch_async（）时，dispatch_async（）会在另一个线程里运行，然后立即执行something 4。待dispatch_async（）执行something3。完成之后，回来原来的线程。<br>因此顺序为1，2，4，3。从这里我们可以看出dispatch_sync与dispatch_async的区别。</p>
<h3 id="u4F7F_u7528dispatch_sync_u7684_u6CE8_u610F_u70B9"><a href="#u4F7F_u7528dispatch_sync_u7684_u6CE8_u610F_u70B9" class="headerlink" title="使用dispatch_sync的注意点"></a>使用dispatch_sync的注意点</h3><p>在dispatch_sync嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁。可以看下面的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> myQueue =</span><br><span class="line">    dispatch_queue_create(<span class="string">"com.testSerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(myQueue, ^&#123;<span class="comment">// block1 begin</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block1"</span>);</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(myQueue, ^&#123;<span class="comment">// block2 begin</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block2"</span>);</span><br><span class="line">        &#125;);<span class="comment">// block2 end</span></span><br><span class="line">    &#125;);<span class="comment">// block1 end</span></span><br><span class="line">    <span class="comment">//输出：block1</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，只有block1被打印出来，而block2始终无法打印，这就是死锁。那么死锁产生的原因是什么呢？<br>因为所有的dispatch queue都是线程安全的，所以在上面代码中的每个block中会加锁，当进入block1时，GCD给block1加锁，直到block1 end时，锁才能解开。而进入block2时，锁还加在block1中。于是block2始终在等待block1 end，而block1又在等待block2 end。两者相互等待对方结束，自己才能结束，这样就进入了死锁。</p>
<h3 id="u4E3A_u4EC0_u4E48_u9700_u8981dispatch_sync"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981dispatch_sync" class="headerlink" title="为什么需要dispatch_sync"></a>为什么需要dispatch_sync</h3><p>一开始接触GCD的时候，我一直不明白为什么要有dispatch_sync。因为dispatch_sync不像dispatch_async一样能够借着异步能够带来用户体验上的提升，把一些需要下载的任务丢到从线程，当下载完毕之后再调入主线程。<br>在下面一节，用GCD保护property时，getter方法就是用的dispatch_sync。因为我们不会希望当值还没有赋给实例变量时，就已经return了。</p>
<h2 id="u4F7F_u7528Serial_Dispatch_Queue_u548Cdispatch_barrier_async_u4FDD_u62A4property"><a href="#u4F7F_u7528Serial_Dispatch_Queue_u548Cdispatch_barrier_async_u4FDD_u62A4property" class="headerlink" title="使用Serial Dispatch Queue和dispatch_barrier_async保护property"></a>使用Serial Dispatch Queue和dispatch_barrier_async保护property</h2><p>setter和getter方法是在程序中经常需要用到的方法，是否可以使用GCD来加快他们的执行速度呢？答案肯定是有的，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentQueue;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line">	</span><br><span class="line">_concurrentQueue = dispatch_queue_create(<span class="string">"com.zhangbuhuai.test"</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">// getter方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// setter方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为setter方法不需要返回，所以可以采用异步的方式来执行。而barrier只能保证『写操作』不被同一个队列中的其他任务干扰，但无法保证不被其他队列中的任务干扰。因此getter方法需要用同步的方法来保证和setter在同一队列中。</p>
<h2 id="u4F7F_u7528dispatch_once_u6765_u6267_u884C_u53EA_u9700_u8FD0_u884C_u4E00_u6B21_u7684_u7EBF_u7A0B_u5B89_u5168_u4EE3_u7801"><a href="#u4F7F_u7528dispatch_once_u6765_u6267_u884C_u53EA_u9700_u8FD0_u884C_u4E00_u6B21_u7684_u7EBF_u7A0B_u5B89_u5168_u4EE3_u7801" class="headerlink" title="使用dispatch_once来执行只需运行一次的线程安全代码"></a>使用dispatch_once来执行只需运行一次的线程安全代码</h2><p>单例模式（singleton）对任何语言的开发者而言都不陌生，常见的实现方式为：在类编写名为sharedInstance的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。<br>考虑线程安全和性能的情况下，单例模式可以这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> TestClass *sharedInstance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;	</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以选择GCD来实现单列模式，是因为使用disptch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的token，所以token要声明成static。把该变量定义在static作用域中，可以保证编译器在每次执行sharedInstance方法时都会复用这个变量，而不会创建新变量。<br>此外，dispatch_once更高效。它没有使用重量级的同步机制，若是那样做的话，每次运行代码前都要获取锁，相反，此函数采用“原子访问”（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。</p>
<ol>
<li>《Objective-C高级编程》Kazuki Sakamoto，Tomohiko Furumoto </li>
<li>《Effective Objective-C 2.0》 Matt Galloway</li>
<li><a href="http://www.cocoachina.com/industry/20140428/8248.html" target="_blank" rel="external">GCD深入理解(一)</a></li>
<li><a href="http://www.cocoachina.com/industry/20140515/8433.html" target="_blank" rel="external">GCD深入理解(二)</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-知乎日报-仿" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/17/知乎日报-仿/" class="article-date">
  	<time datetime="2016-05-17T01:43:50.000Z" itemprop="datePublished">2016-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/17/知乎日报-仿/">知乎日报(仿)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>陆陆续续写了两个星期，自己的第一个Demo APP的基本框架已经搭好了。非常幸运的是目前仿知乎日报的APP在github上已经有很多了，而且写得很好的也有不少。另外非常感谢izzyleung提供的API，让我们可以有做知乎日报的前提。</p>
<h2 id="u6570_u636E_u5C42"><a href="#u6570_u636E_u5C42" class="headerlink" title="数据层"></a>数据层</h2><p>因为底层的数据API都是知乎（Zhihu.Inc）提供的，我只能读取数据给业务层加工，所以数据层并不在我的设计范围之内。不过，后期可能会使用fmdb实现一些本地登录、收藏的功能，但仅限于本地操作。</p>
<h2 id="u4E1A_u52A1_u5C42"><a href="#u4E1A_u52A1_u5C42" class="headerlink" title="业务层"></a>业务层</h2><p>业务层是一个数据加工场，处理核心的业务逻辑，从API提取的数据经过业务层的加工提供给表示层。<br>主要的类有：</p>
<ol>
<li>YQHttpTool：用于封装基于AFNetWorking的GET方法；</li>
<li>YQThemesTool：取得知乎日报API返回的theme信息；</li>
<li>YQStoriesTool：取得知乎日报API返回的新闻信息，包括新闻标题、新闻图片、内容ID</li>
<li>YQSessionTool：以返回的date对新闻进行不同的session分组。</li>
</ol>
<h2 id="u8868_u793A_u5C42"><a href="#u8868_u793A_u5C42" class="headerlink" title="表示层"></a>表示层</h2><p>所有的功能页面等都属于这一类，整个APP可以分成4个功能页面：</p>
<ol>
<li>leftDrawerView：左抽屉视图，主要包含主题日报，点击跳转进入相应的themeView；<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%202016%E5%B9%B45%E6%9C%8817%E6%97%A5%20%E4%B8%8B%E5%8D%883.03.48.png" alt="左抽屉视图"></li>
<li>mainView：主视图，知乎日报首页，提供每天的『今日热闻』，点击跳转到相应的detailView；<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/Simulator%20Screen%20Shot%202016%E5%B9%B45%E6%9C%8817%E6%97%A5%20%E4%B8%8B%E5%8D%883.03.45.png" alt="主视图"></li>
<li>themeView：主题日报，包含每个主题的推荐内容，点击跳转到相应的detailView；</li>
<li>detailView：新闻视图，根据storyID来获取新闻内容。</li>
</ol>
<p>代码<a href="https://github.com/oushiyq/YQZhihuDaily" target="_blank" rel="external">在这</a></p>
<p>参考资料：</p>
<ol>
<li>《iOS编程》Christian Keur，Aaron Hillegass，Joe Conway </li>
<li><a href="https://github.com/chatwyn/WBZhiHuDailyPaper" target="_blank" rel="external">知乎日报（仿）</a></li>
<li><a href="https://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90" target="_blank" rel="external">知乎日报 API 分析</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入浅出block" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/深入浅出block/" class="article-date">
  	<time datetime="2016-05-10T08:01:22.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/深入浅出block/">理解block</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前在看《iOS编程》的时候，并没有感觉block有多难，就感觉是一个语法和指针函数差不多的一种匿名函数。但是之后在看了《Objective-C高级编程》和《Effective Objective-C 2.0》之后，发现学长和我说的『block、ARC、GCD、runtime、runloop都属于高级编程的范畴』，果然是没错的。今天在编写『知乎日报』时，也在block中遇到一点困难，于是总结一下block的用法吧！</p>
<h2 id="Block_u7B80_u4ECB"><a href="#Block_u7B80_u4ECB" class="headerlink" title="Block简介"></a>Block简介</h2><p>block作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅<strong>实现函数的功能</strong>，还能<strong>携带函数的执行环境</strong>。</p>
<p>可以这样理解，Block其实包含两个部分内容</p>
<ol>
<li>Block执行的代码，这是在编译的时候已经生成好的；</li>
<li>一个包含Block执行时需要的所有外部变量值的数据结构。Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。</li>
</ol>
<h2 id="Block_u57FA_u672C_u8BED_u6CD5"><a href="#Block_u57FA_u672C_u8BED_u6CD5" class="headerlink" title="Block基本语法"></a>Block基本语法</h2><p>先给出一个最简单的定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="keyword">void</span> (<span class="keyword">void</span>)&#123;</span><br><span class="line">	printf(<span class="string">"这是一个block\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，一个block在语法上可以由4部分组成:<strong> ^ 返回值类型 参数列表 表达式 </strong><br>当返回值类型为void，或者根据表达式可以知道其返回值类型时，返回值类型可以省略。那么block就由3部分组成：<strong> ^ 参数列表 表达式 </strong><br>具体例子如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (<span class="keyword">void</span>)&#123;</span><br><span class="line">	printf(<span class="string">"这是一个block\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^ (<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该block语法按照return语句的类型，返回int返回值</span></span><br></pre></td></tr></table></figure>
<p>当然，如果你的block语句中没有参数，那么参数列表也能省略，block语句变成：<strong> ^ 表达式 </strong>。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">	printf(<span class="string">"这是一个block\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Block_u7C7B_u578B_u53D8_u91CF"><a href="#Block_u7C7B_u578B_u53D8_u91CF" class="headerlink" title="Block类型变量"></a>Block类型变量</h2><p>在block语法中，可将block语法赋值给声明为block类型的变量。声明block类型变量的示例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="keyword">int</span> (^blk)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>既然说block是变量，那么他肯定是可以初始化以及赋值的咯，如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block变量初始化</span></span><br><span class="line">^<span class="keyword">int</span> (^blk)(<span class="keyword">int</span>) = ^ (<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> count++;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//block变量赋值</span></span><br><span class="line"><span class="keyword">int</span> (^blk1)(<span class="keyword">int</span>) = blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^blk2)(<span class="keyword">int</span>);</span><br><span class="line">blk2 = blk1;</span><br></pre></td></tr></table></figure></p>
<p>这举的都是比较简单的例子，当block语法的结构变复杂时，这种语法会变得非常难记、难读。因此，我们可以为block起名来表示block的用途，并把其类型隐藏。这就用到了c语言中常见的typedef，比如将上面的代码可以进行以下的改写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//定义一个名为blk的类型</span></span><br><span class="line"></span><br><span class="line">blk blk1 = ^ (<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> count++;&#125;;</span><br><span class="line">blk blk2 = blk1;</span><br></pre></td></tr></table></figure></p>
<p>这样，就很轻松的定义了一个返回值和参数都为int类型的block变量了。</p>
<h2 id="u7406_u89E3__block"><a href="#u7406_u89E3__block" class="headerlink" title="理解__block"></a>理解__block</h2><p>block可以理解为『带有自动变量的匿名函数』，其中『带有自动变量』在block中的表现为『截获自动变量』。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> (^logging)(<span class="keyword">void</span>);</span><br><span class="line">        logging blk =  ^ &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"a的值是：%d\n"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//print : a的值是：1</span></span><br></pre></td></tr></table></figure></p>
<p>在该源代码中，block语法表达式使用的是之前声明的a的值。因为在block表达式中会保存自动变量的值，并不会随自动变量值的改写而改变。这就是自动变量的截获。<br>若想改变在block语法的表达式中的自动变量，那么只需要在自动变量前面加入__block修饰符就行了。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在block外修改自动变量</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> (^logging)(<span class="keyword">void</span>);</span><br><span class="line">        logging blk =  ^ &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"a的值是：%d\n"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//print : a的值是：2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在block内修改自动变量</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> (^logging)(<span class="keyword">void</span>);</span><br><span class="line">        logging blk =  ^ &#123;</span><br><span class="line">                    a = <span class="number">2</span>;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"a的值是：%d\n"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print : a的值是：2</span></span><br></pre></td></tr></table></figure></p>
<p>当block截获被__block修饰的自动变量时，block中自动变量的值是可以改变的。</p>
<h2 id="Block_u4E0E_u5BF9_u8C61_u7684_u5173_u7CFB"><a href="#Block_u4E0E_u5BF9_u8C61_u7684_u5173_u7CFB" class="headerlink" title="Block与对象的关系"></a>Block与对象的关系</h2><p>在苹果公司的官方文档中关于block有这么一句话：</p>
<blockquote>
<p>Blocks are Objective-C objects, which means they can be added to collections like NSArray or NSDictionary.<br>在这里苹果明确是指出了block是一个对象，那么作为一个对象，他和其他对象是否有区别呢？这个可以从block的底层定义出发。在《Objective-C高级编程》中，作者使用clang编译得到了block的结构，如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __block_impl 是 block 实现的结构体</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>可以看到block实现的结构体中包含了一个isa的指针，而我们很清楚isa在oc中表示的是对象的类型。在block中默认的block类型为_NSConcreteStackBlock。如同名字一样，block对象默认为在栈上分配，而普通对象一般分配在堆中。这就是block对象和对象之间的区别。</p>
<h2 id="block_u7684_u7C7B_u578B_u4E0E_u4F7F_u7528"><a href="#block_u7684_u7C7B_u578B_u4E0E_u4F7F_u7528" class="headerlink" title="block的类型与使用"></a>block的类型与使用</h2><p>在上一节中说到block对象类型默认为_NSConcreteStackBlock，那么是否还有其他类型？答案是肯定的，block一共有三种类型：_NSConcreteGlobalBlock、_NSConcreteStackBlock和_NSConcreteMallocBlock。其区别如下：</p>
<table>
<thead>
<tr>
<th>类</th>
<th style="text-align:center">block对象的存储域</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td style="text-align:center">栈</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td style="text-align:center">.data区</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td style="text-align:center">堆</td>
</tr>
</tbody>
</table>
<p>我们可以自己在定义全局变量的地方定义一个_NSConcreteGlobalBlock类型的block对象。另外，我们实现一个不使用应截获的自动变量的block时，也会显示为是它。如果有对自动变量的引用，那么就会显示_NSConcreteStackBlock，他会随着变量作用域的结束而废弃。_NSConcreteMallocBlock就如同malloc表示的一样，在对_NSConcreteStackBlock类型的block进行Block_copy()或者发送了copy时就会得到。<br>因此，在我们对block的使用中，我们应该注意_NSConcreteStackBlock类型的block如果在变量作用域结束后还要存在，那么我们需要对其copy操作。</p>
<p>参考资料：</p>
<ol>
<li>《Objective-C高级编程 iOS与OS X多线程和内存管理》Kazuki Sakamoto，Tomohiko Furumoto </li>
<li>《Effective Objective-C 2.0》 Matt Galloway</li>
<li>《iOS开发进阶》 唐巧</li>
<li>《iOS编程》Christian Keur，Aaron Hillegass，Joe Conway </li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
<li><a href="http://www.molotang.com/articles/1691.html" target="_blank" rel="external">深入理解Objective-C的Block</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-最近需要用到的一些第三方库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/03/最近需要用到的一些第三方库/" class="article-date">
  	<time datetime="2016-05-03T01:38:10.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/最近需要用到的一些第三方库/">最近需要用到的一些第三方库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在做一个高仿的知乎日报APP，把其需要的一些第三方库的资料复制在下面，以便查阅。</p>
<h2 id="MJExtension"><a href="#MJExtension" class="headerlink" title="MJExtension"></a><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">MJExtension</a></h2><h2 id="YYModel"><a href="#YYModel" class="headerlink" title="YYModel"></a><a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">YYModel</a></h2><h2 id="MMDrawerController"><a href="#MMDrawerController" class="headerlink" title="MMDrawerController"></a><a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">MMDrawerController</a></h2><h2 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a></h2><h2 id="fmdb"><a href="#fmdb" class="headerlink" title="fmdb"></a><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">fmdb</a></h2><h2 id="MBProgressHUD"><a href="#MBProgressHUD" class="headerlink" title="MBProgressHUD"></a><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external">MBProgressHUD</a></h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-protocol和delegate" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/14/protocol和delegate/" class="article-date">
  	<time datetime="2016-04-14T11:31:56.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/protocol和delegate/">Protocol和Delegate</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>说来惭愧，直到昨天，我还对protocol和delegate之间的区别有所疑惑。总认为他们俩之间有些相似之处，然而他们俩者完全是不同的东西！</p>
<h2 id="u4E3A_u4EC0_u4E48_u6211_u4EEC_u9700_u8981protocol"><a href="#u4E3A_u4EC0_u4E48_u6211_u4EEC_u9700_u8981protocol" class="headerlink" title="为什么我们需要protocol"></a>为什么我们需要protocol</h2><p>在Objective-C中，继承是单一继承，即不支持如C++的多继承方式。然而，我们有时候又强烈的需要多继承的方法，这就是protocol的作用了。我们可以把某个类应该实现的一系列方法定义在protocol里面，其他的类采用该protocol，那么就相对于他同时继承了父类和protocol中定义的一系列方法。</p>
<h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><p>protocol是一系列方法的声明列表，只要某个类采用了这个protocol，那么这个类便拥有了协议中的所有方法声明。但是协议只是负责声明对象需要的方法，而这些个实现方法与protocol无关。其语法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">myProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">    <span class="comment">//方法声明1</span></span><br><span class="line">    <span class="comment">//方法声明2</span></span><br><span class="line">    <span class="comment">//方法声明3</span></span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>要拥有协议中声明的方法，就必须遵守protocol，如果某个类遵守的协议有多个，则用逗号进行分隔。其语法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 类名 : 父类&lt;<span class="title">protocol_1</span>，<span class="title">protocol_2</span>, ……&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h2><p>delegate是一种设计模式，这种模式用于应用程序的一个对象delegate另外一个对象和其他对象交互。总而言之，delegate只是一种设计模式而已，是大家约定俗成的一种做法。在OC中，通常使用协议来实现代理，即把协议当成用户和代理中间的『中转站』，在协议中定义一些和代理沟通的方法。也就是因为这个原因，初学者会经常把Protocol和Delegate弄混淆。<br>这里举个例子吧：<br>假如有个A类，他把需要的事交给B类处理，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">classA</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">	classB *B；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>只需要在A类中声明一个B类的ivar就行了，这就是delegate……他真的只是一个设计模式而已。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS中的MVC设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/14/iOS中的MVC设计模式/" class="article-date">
  	<time datetime="2016-04-14T08:48:43.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/iOS中的MVC设计模式/">iOS中的MVC设计模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>MVC（Model-View-Controller）,作为iOS开发的一个主流设计模式，很多初学者第一次接触设计模式也是从MVC开始的。虽然我一直在用这种模式，但是对于他的理解还一直处于一个很模糊的状态，于是又回去看了看斯坦福的iOS教程。同时，也Google了一些别人的blog，慢慢开始对MVC越来越清晰。</p>
<h2 id="MVC_u8BBE_u8BA1_u6A21_u5F0F"><a href="#MVC_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/97B060C0-E1B8-46B0-95B7-2740392E9ABE.png" alt="MVC"></p>
<p>Model:封装了应用程序的数据，并定义了处理逻辑；<br>View:应用程序中，用户看到的对象；<br>Controller:视图与模型之间通信的媒介。<br>如上图所示，他们的之间的通信方式如下：</p>
<ol>
<li>Model与View永远不能直接通信；</li>
<li>Controller和Model之间的通信需借助Notification和KVO模式；</li>
<li>Controller和View之间的通信可以通过outlet直接操作view，即outlet直接对应View中的控件。View通过action-target机制向Controller报告事件的发生。另外，Controller作为View的delegate协助View处理数据，来达到View和Controller之间的同步。</li>
</ol>
<h2 id="MVC_u5B58_u5728_u7684_u95EE_u9898_u4EE5_u53CA_u6539_u8FDB"><a href="#MVC_u5B58_u5728_u7684_u95EE_u9898_u4EE5_u53CA_u6539_u8FDB" class="headerlink" title="MVC存在的问题以及改进"></a>MVC存在的问题以及改进</h2><p>不可否认MVC是一个非常优秀的设计模式，它能很直观的体现app中的各个组件的相关关系。但是由于Controller集中了大量代码，使得其Controller层过于臃肿。<br>而设计模式很多时候是为了 Don’t repeat yourself 原则来做的，该原则要求能够复用的代码要尽量复用，来保证重用。MVC的View和Model都符合该原则。但是Controller并不易于复用。那么在MVC中，我们应该把哪些代码放在Controller中呢？因为其难以复用，那么把一些不需要复用代码放入其中，如：</p>
<ol>
<li>初始化时，构造相应的View和Model；</li>
<li>监听Model层的事件，将数据传给View层；</li>
<li>监听View层的事件，将数据传给Model层。</li>
</ol>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM（Model-View-ViewModel）在使用当中，通常还会利用双向绑定技术，使得Model变化时，ViewModel 会自动更新，而ViewModel变化时，View也会自动变化。所以，MVVM模式有些时候又被称作：model-view-binder模式。<br>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</p>
<ol>
<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>参考资料:<br>1.《iOS开发进阶》 唐巧<br>2.《斯坦福大学公开课:iOS 7应用开发》 Paul Hegarty</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-字符串翻转" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/03/字符串翻转/" class="article-date">
  	<time datetime="2016-04-03T01:47:34.000Z" itemprop="datePublished">2016-04-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/03/字符串翻转/">字符串翻转</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>昨天腾讯笔试，结果第一道编程题就gg了，还以为是笔试的编译器出问题了，一直不能输出……Orz<br>结果考完在自己的编译器也同样无法输出，然后就知道自己跪了。。。</p>
<h3 id="u9898_u76EE"><a href="#u9898_u76EE" class="headerlink" title="题目"></a>题目</h3><p>很简单的题目，也是很简单的算法，输入一个字符串如：”I come from China.”,输出”China. from come I”。思路很简单，就是先整个翻转字符串”.anihC morf emoa I”，然后以空格为界，分别对每个子字符串翻转。<br>下面贴出代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include<span class="title">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#include<span class="title">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main ()&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i,begin,end;</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">long</span> length = strlen(str)-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//整个翻转字符串</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; length&gt;i; i++,length--) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        tmp = str[i];</span><br><span class="line">        str[i] = str[length];</span><br><span class="line">        str[length] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//翻转子字符串</span></span><br><span class="line">     <span class="keyword">while</span>(str[i]) &#123;</span><br><span class="line">         begin = i;</span><br><span class="line">         <span class="keyword">while</span> (str[i] != <span class="string">' '</span> &amp;&amp; str[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">         &#125;</span><br><span class="line">         end = i-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">while</span>(end &gt; begin) &#123;</span><br><span class="line">             <span class="keyword">char</span> tmp;</span><br><span class="line">             tmp = str[end];</span><br><span class="line">             str[end] = str[begin];</span><br><span class="line">             str[begin] = tmp;</span><br><span class="line">             end--;</span><br><span class="line">             begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入：I come frome China</span></span><br><span class="line"><span class="comment">//输出：China frome come I</span></span><br></pre></td></tr></table></figure></p>
<p>记得当时好想是在while (str[i] != ‘ ‘ &amp;&amp; str[i])这个判断中忘记『&amp;&amp; str[i]』这个条件了，后来在Xcode中debug的时候才找出来的，没有『&amp;&amp; str[i]』将在字符串中一直查找，导致无法输出。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-理解Runtime之消息转发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/23/理解Runtime之消息转发/" class="article-date">
  	<time datetime="2016-03-23T02:54:02.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/理解Runtime之消息转发/">理解Runtime之消息转发</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6D88_u606F_u4F20_u9012_u673A_u5236"><a href="#u6D88_u606F_u4F20_u9012_u673A_u5236" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>消息是由接受者、选择子和参数构成，给某对象『发送消息』也就相当于『调用方法』。发给某对象的全部消息都要由『动态消息派发系统』来处理，该系统会查出相应的方法，并执行代码。举个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</span><br><span class="line"><span class="comment">//[someObject messageName:parameter]就是消息</span></span><br><span class="line"><span class="comment">//someObject为接受者</span></span><br><span class="line"><span class="comment">//messageName为选择子也可以说是方法</span></span><br><span class="line"><span class="comment">//parameter参数</span></span><br></pre></td></tr></table></figure></p>
<p>在runtime，『动态消息派发系统』会依据接受者（即上述对象someObject）和选择子类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其『方法列表』，如果能找到与『选择子』匹配的方法，就调至其实现的代码。若找不到，那就沿着继承体系往父类查找，等找到合适的方法之后再跳转。如果最终还找不到相匹配的方法，那就执行『消息转发』</p>
<h2 id="u6D88_u606F_u8F6C_u53D1"><a href="#u6D88_u606F_u8F6C_u53D1" class="headerlink" title="消息转发"></a>消息转发</h2><ol>
<li><p>首先调用其所属类的下列方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果resolveInstanceMethod类方法无法解决，那么调用备援接收者:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果forwardingTargetForSelector还是无法解决，那么就要进行完整的消息转发：<br>首先创建NSInvocation对象，把与尚未处理的那条消息有关的全部细节都封装于其内。包括selector、target以及参数。触发NSInvocation时，『动态消息派发系统』把消息派给target。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardingInvocation:(<span class="built_in">NSInvocation</span>)invocation</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>用流程图表示如下：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/QQ20150427-1.png" alt=""><br>Receiver在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大；最好能在第一步就处理完，这样的话，runtime系统就可以将此方法缓存起来，进而提高效率。若想在第三步里把消息转发给备援的receiver，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步会更为简单，不然的话，还得创建并处理完整的NSInvocation。</p>
<p>参考资料：<br>《Effective Objective-C 2.0》</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入理解KVO" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/16/深入理解KVO/" class="article-date">
  	<time datetime="2016-03-16T12:03:19.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/深入理解KVO/">简单使用KVO</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_KVC_u7684_u6982_u5FF5"><a href="#1-_KVC_u7684_u6982_u5FF5" class="headerlink" title="1. KVC的概念"></a>1. KVC的概念</h2><p>KVC（key-value coding）是指将表示对象包含的信息的字符串作为键值来使用，间接访问该信息的方式。</p>
<h2 id="2-_KVO_u4E0ERuntime"><a href="#2-_KVO_u4E0ERuntime" class="headerlink" title="2. KVO与Runtime"></a>2. KVO与Runtime</h2><p>KVO（key-value observe）即某个对象的属性改变时通知其他对象的机制。KVO的实现也依赖于Objective-C的Runtime，官方文档《Key-Value Observing Programming Guide》中在《Key-Value Observing Implementation Details》部分简单提到它的实现：</p>
<hr>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
<hr>
<p>大概的意思就是KVO的实现是通过isa-swizzling技术。这个技术表示，当观察者观察一个对象时，会产生一个新的类，这个类继承于被观察对象，并重写其setter方法，再将被观察对象的isa指针指向新的类。这样被观察对象就神奇的成为了新类的实例。这样看来，KVO的实现还是有点黑魔法的意思啊。</p>
<h2 id="3-_KVO_u7684_u4F7F_u7528"><a href="#3-_KVO_u7684_u4F7F_u7528" class="headerlink" title="3. KVO的使用"></a>3. KVO的使用</h2><h3 id="3-1__u8BA2_u9605"><a href="#3-1__u8BA2_u9605" class="headerlink" title="3.1 订阅"></a>3.1 订阅</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">            context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<h3 id="3-2__u54CD_u5E94"><a href="#3-2__u54CD_u5E94" class="headerlink" title="3.2 响应"></a>3.2 响应</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>
<h3 id="3-3__u79FB_u9664"><a href="#3-3__u79FB_u9664" class="headerlink" title="3.3 移除"></a>3.3 移除</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">               context:(<span class="keyword">void</span> *)context;</span><br><span class="line">               </span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<h3 id="3-4__u793A_u4F8B_u7A0B_u5E8F"><a href="#3-4__u793A_u4F8B_u7A0B_u5E8F" class="headerlink" title="3.4 示例程序"></a>3.4 示例程序</h3><p>在下面的例子中，通过对UITextField.text值的观察，当其变化时，新值将在弹出窗口中被打印出来。效果如下：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/2016-03-17%2009_36_54.gif" alt=""></p>
<p>以下是源代码：<br>h文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *showText;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) IBOutletCollection(<span class="built_in">UIButton</span>) <span class="built_in">NSArray</span> *numberButton;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)clickNumberButton:(<span class="keyword">id</span>)sender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>m文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="string">@"showText.text"</span></span><br><span class="line">              options:<span class="number">1</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)clickNumberButton:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> buttonIndex = [<span class="keyword">self</span><span class="variable">.numberButton</span> indexOfObject:sender];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *content = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)buttonIndex ];</span><br><span class="line">    [content stringByAppendingFormat:<span class="string">@"%lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)buttonIndex];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.showText</span><span class="variable">.text</span> = [<span class="keyword">self</span><span class="variable">.showText</span><span class="variable">.text</span> stringByAppendingString:content];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *currentString = [change valueForKey:<span class="string">@"new"</span>];</span><br><span class="line">    <span class="comment">//弹窗</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alertController = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"输入的数字为："</span></span><br><span class="line">                                                                             message:currentString</span><br><span class="line">                                                                      preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *cancelAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span></span><br><span class="line">                                                           style:<span class="built_in">UIAlertActionStyleCancel</span></span><br><span class="line">                                                         handler:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *okAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"好的"</span></span><br><span class="line">                                                       style:<span class="built_in">UIAlertActionStyleDefault</span></span><br><span class="line">                                                     handler:<span class="literal">nil</span>];</span><br><span class="line">    [alertController addAction:cancelAction];</span><br><span class="line">    [alertController addAction:okAction];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-4__u6CE8_u610F_u4E8B_u9879"><a href="#3-4__u6CE8_u610F_u4E8B_u9879" class="headerlink" title="3.4 注意事项"></a>3.4 注意事项</h2><ol>
<li>keypath的拼写。因为keypath为一字符串，所以很容易产生拼写错误导致无法监听。比如本来keypath = @”contents”，但有时未注意可能会拼写成keypath = @”content”，而编译器在编译时也无法发现错误。因此可以定义一个常量static const NSString *contens = @”contents”；</li>
<li>多次使用removeObserver导致程序crash。在同一个文件中执行两次相同的removeObserver比较容易debug出来；但是跨文件执行两次相同的removeObserver就不是那么容易发现了。因此Apple推荐在dealloc中进行removeObserver；</li>
</ol>
<p>参考资料：</p>
<ol>
<li>Key-Value Observing Programming Guide</li>
<li><a href="http://objccn.io/issue-7-3/" target="_blank" rel="external">KVC 和 KVO</a> 翻译：卢思豪 </li>
<li><a href="http://khanlou.com/2013/12/kvo-considered-harmful/" target="_blank" rel="external">KVO Considered Harmful</a> KHANLOU</li>
<li>《Objective-C编程全解》 荻原刚志</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ARC模式下的OC对象与Core-Fundation的桥接" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/11/ARC模式下的OC对象与Core-Fundation的桥接/" class="article-date">
  	<time datetime="2016-03-11T10:36:26.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/11/ARC模式下的OC对象与Core-Fundation的桥接/">ARC模式下的OC对象与Core Fundation的桥接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u4EC0_u4E48_u662FToll_Free_Bridge"><a href="#u4EC0_u4E48_u662FToll_Free_Bridge" class="headerlink" title="什么是Toll_Free Bridge"></a>什么是Toll_Free Bridge</h3><p>通常来说为了代码在底层级上的正确，在iOS开发中对基于C的API的调用所传入的参数一般都是CF对象，而Objective-C的API调用都是传入NSObject对象。因此在采用toll_free bridge来调用C语言API的时候就需要进行转换。但是在使用ARC编译的时候，因为内存管理的原因，编译器需要知道对这些桥接对象要实行什么样的操作。如果一个NSURL对象替代了CFURLRef，那么在作用区域外，应该由谁来决定内存释放和对象销毁呢？为了解决这个问题，引入了<strong>bridge,bridge_transfer和</strong>bridge_retained三个关键字。关于选取哪个关键字做转换，需要由实际的代码行为来决定。</p>
<h3 id="Bridge_u5173_u952E_u5B57"><a href="#Bridge_u5173_u952E_u5B57" class="headerlink" title="Bridge关键字"></a>Bridge关键字</h3><ul>
<li><p>__bridge：用来完成CF和OC对象的转换，不涉及对象所有权的改变</p>
</li>
<li><p>__bridge_transfer：用来完成CF到OC对象的转换，给予ARC拥有对象，无需手动释放</p>
</li>
<li><p>__bridge_retained：用来完成OC对象到CF的转换，解除ARC对于对象的拥有，需手动释放</p>
</li>
</ul>
<p>参考资料：<br><a href="http://gracelancy.com/blog/2014/04/21/toll-free-bridging/" target="_blank" rel="external">Toll-Free Bridging</a> Lancy<br><a href="https://onevcat.com/2012/06/arc-hand-by-hand/" target="_blank" rel="external">手把手教你ARC——iOS/Mac开发ARC入门和使用</a> OneV’s Den</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>