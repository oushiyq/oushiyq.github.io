<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Daniel Young's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daniel Young's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Core-Animation/" style="font-size: 15px;">Core Animation</a> <a href="/tags/iOS小知识/" style="font-size: 20px;">iOS小知识</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/音视频/" style="font-size: 10px;">音视频</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOS播放AMR文件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/29/iOS播放AMR文件/" class="article-date">
  	<time datetime="2018-12-29T08:17:05.000Z" itemprop="datePublished">2018-12-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/iOS播放AMR文件/">iOS播放AMR文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近公司项目中，有个播放AMR音频的需求。把此次需求中调研的东西记录一下。</p>
<h2 id="u4E00_u3001_u89C6_u9891_u64AD_u653E_u5668_u539F_u7406"><a href="#u4E00_u3001_u89C6_u9891_u64AD_u653E_u5668_u539F_u7406" class="headerlink" title="一、视频播放器原理"></a>一、视频播放器原理</h2><p>视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。</p>
<p>视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。</p>
<p><img src="https://img-blog.csdn.net/20140201120523046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="视频播放流程图"></p>
<p><strong>解协议</strong>：就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<p><strong>解封装</strong>：就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<p><strong>解码</strong>：就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p>
<p><strong>视音频同步</strong>：就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<h2 id="u4E8C_u3001_AMR"><a href="#u4E8C_u3001_AMR" class="headerlink" title="二、 AMR"></a>二、 AMR</h2><p>AMR语音帧格式为帧头和语音数据组成。其结构为</p>
<p>| 帧头 | 语音数据 |</p>
<p>其中 帧头占一个字节，具体结构如下：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>FT</td>
<td>FT</td>
<td>FT</td>
<td>FT</td>
<td>Q</td>
<td>P</td>
<td>P</td>
</tr>
</tbody>
</table>
<p>其中: P = 0，Q为帧质量指示器，0表示坏帧。FT对应不同的编码，如下所示</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>FT</th>
</tr>
</thead>
<tbody>
<tr>
<td>AMR 4.75</td>
<td>0000</td>
</tr>
<tr>
<td>AMR 5.15</td>
<td>0001</td>
</tr>
<tr>
<td>AMR 5.9</td>
<td>0010</td>
</tr>
<tr>
<td>AMR 6.7</td>
<td>0011</td>
</tr>
<tr>
<td>AMR 7.4</td>
<td>0100</td>
</tr>
<tr>
<td>AMR 7.95</td>
<td>0101</td>
</tr>
<tr>
<td>AMR 10.2</td>
<td>0110</td>
</tr>
<tr>
<td>AMR 12.2</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p><img src="https://p-blog.csdn.net/images/p_blog_csdn_net/dinggo/4.bmp" alt="AMR音频读取流程图"></p>
<h2 id="u4E09_u3001_WAV"><a href="#u4E09_u3001_WAV" class="headerlink" title="三、 WAV"></a>三、 WAV</h2><p><code>WAV</code>文件遵循RIFF规则，其内容以区块（<code>chunk</code>）为最小单位进行存储。<code>WAV</code>文件一般由3个区块组成：<code>RIFF chunk</code>、<code>Format chunk</code>和<code>Data chunk</code>。另外，文件中还可能包含一些可选的区块，如：<code>Fact chunk</code>、<code>Cue points chunk</code>、<code>Playlist chunk</code>、<code>Associated data list chunk</code>等。</p>
<p><img src="https://img-blog.csdn.net/20160911090642999" alt="wav格式图"></p>
<ol>
<li>RIFF chunk</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>偏移地址</th>
<th>字节数</th>
<th>端序</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>0x00</td>
<td>4Byte</td>
<td>大端</td>
<td>‘RIFF’ (0x52494646)</td>
</tr>
<tr>
<td>Size</td>
<td>0x04</td>
<td>4Byte</td>
<td>小端</td>
<td>fileSize - 8</td>
</tr>
<tr>
<td>Type</td>
<td>0x08</td>
<td>4Byte</td>
<td>大端</td>
<td>‘WAVE’(0x57415645)</td>
</tr>
</tbody>
</table>
<ul>
<li><p>以<code>&#39;RIFF&#39;</code>为标识</p>
</li>
<li><p><code>Size</code>是整个文件的长度减去<code>ID</code>和<code>Size</code>的长度</p>
</li>
<li><p><code>Type</code>是<code>WAVE</code>表示后面需要两个子块：<code>Format</code>区块和<code>Data</code>区块</p>
</li>
</ul>
<ol>
<li>FORMAT chunk</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>偏移地址</th>
<th>字节数</th>
<th>端序</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>0x00</td>
<td>4Byte</td>
<td>大端</td>
<td>‘fmt ‘ (0x666D7420)</td>
</tr>
<tr>
<td>Size</td>
<td>0x04</td>
<td>4Byte</td>
<td>小端</td>
<td>16</td>
</tr>
<tr>
<td>AudioFormat</td>
<td>0x08</td>
<td>2Byte</td>
<td>小端</td>
<td>音频格式</td>
</tr>
<tr>
<td>NumChannels</td>
<td>0x0A</td>
<td>2Byte</td>
<td>小端</td>
<td>声道数</td>
</tr>
<tr>
<td>SampleRate</td>
<td>0x0C</td>
<td>4Byte</td>
<td>小端</td>
<td>采样率</td>
</tr>
<tr>
<td>ByteRate</td>
<td>0x10</td>
<td>4Byte</td>
<td>小端</td>
<td>每秒数据字节数</td>
</tr>
<tr>
<td>BlockAlign</td>
<td>0x14</td>
<td>2Byte</td>
<td>小端</td>
<td>数据块对齐</td>
</tr>
<tr>
<td>BitsPerSample</td>
<td>0x16</td>
<td>2Byte</td>
<td>小端</td>
<td>采样位数</td>
</tr>
</tbody>
</table>
<ul>
<li><p>以<code>&#39;fmt &#39;</code>为标识</p>
</li>
<li><p><code>Size</code>表示该区块数据的长度（不包含<code>ID</code>和<code>Size</code>的长度）</p>
</li>
<li><p><code>AudioFormat</code>表示<code>Data</code>区块存储的音频数据的格式，<code>PCM</code>音频数据的值为1</p>
</li>
<li><p><code>NumChannels</code>表示音频数据的声道数，1：单声道，2：双声道</p>
</li>
<li><p><code>SampleRate</code>表示音频数据的采样率</p>
</li>
<li><p><code>ByteRate</code>每秒数据字节数 = SampleRate <em> NumChannels </em> BitsPerSample / 8</p>
</li>
<li><p><code>BlockAlign</code>每个采样所需的字节数 = NumChannels * BitsPerSample / 8</p>
</li>
<li><p><code>BitsPerSample</code>每个采样存储的bit数，8：8bit，16：16bit，32：32bit</p>
</li>
</ul>
<ol>
<li>DATA chunk</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>偏移地址</th>
<th>字节数</th>
<th>端序</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID</td>
<td>0x00</td>
<td>4Byte</td>
<td>大端</td>
<td>‘data’ (0x64617461)</td>
</tr>
<tr>
<td>Size</td>
<td>0x04</td>
<td>4Byte</td>
<td>小端</td>
<td>N</td>
</tr>
<tr>
<td>Data</td>
<td>0x08</td>
<td>NByte</td>
<td>小端</td>
<td>音频数据</td>
</tr>
</tbody>
</table>
<ul>
<li>以<code>&#39;data&#39;</code>为标识</li>
<li><code>Size</code>表示音频数据的长度，N = ByteRate * seconds</li>
<li><code>Data</code>音频数据</li>
</ul>
<h2 id="u56DB_u3001_AMR_u8F6CWAV"><a href="#u56DB_u3001_AMR_u8F6CWAV" class="headerlink" title="四、 AMR转WAV"></a>四、 AMR转WAV</h2><p>由于苹果在iOS在4.3以后的版本，取消了对AMR文件的硬解。因此，我们需要使用libopencore来将AMR文件转成苹果支持的WAV格式进行播放。</p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="external">总结]视音频编解码技术零基础学习方法</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/音视频/">音视频</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Category方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/11/27/Category方法/" class="article-date">
  	<time datetime="2018-11-27T07:19:29.000Z" itemprop="datePublished">2018-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/27/Category方法/">Category方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>对于静态库中的category方法。在静态链接时，category因为其动态加载的特性导致其目标文件（.o）没有被其他目标文件调用，从而linker认为category没有被使用。因此，在linker把静态库中的所有目标文件link成为一个.a文件时，linker并不会将category的目标文件进行link，这就导致了静态库中的category无法调用。</p>
<p>为了解决这个问题，我们可以将xcode中的 “Other Linker Flags”设置为’-ObjC’、 ‘-all_load’ 或者是 ‘-force_load’ 。强行将静态库中的所有.o文件link。</p>
<p>-<strong>all_load</strong> Loads all members of static archive libraries.</p>
<p>-<strong>ObjC</strong> Loads all members of static archive libraries that implement an Objective-C class or category.</p>
<p>-<strong>force_load (path_to_archive)</strong> Loads all members of the specified static archive library. Note: -all_load forces all members of all archives to be loaded. This option allows you to target a specific archive.</p>
</li>
<li><p>对于覆盖了原生方法的category方法。根据runtime中category的实现，我们知道category只是将category方法放在了原来类的实例方法的前面，而OC只要找到了对应的方法就不会沿着方法列表进行查找了。因此，category并没有真正覆盖原生方法。我们只需要找到原来类的方法列表中最后一个对应的实例方法即是原生方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> original_method(<span class="keyword">id</span> cls, <span class="built_in">NSString</span>* methodStr)</span><br><span class="line">&#123;</span><br><span class="line">    Class currentCls = [cls class];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (currentCls)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount;</span><br><span class="line">        Method *methods = class_copyMethodList(currentCls, &amp;methodCount);</span><br><span class="line">        IMP lastImp = <span class="literal">NULL</span>;</span><br><span class="line">        SEL lastSel = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Method method = methods[i];</span><br><span class="line">            <span class="built_in">NSString</span> *methodName = [<span class="built_in">NSString</span> stringWithCString:sel_getName(method_getName(method)) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="keyword">if</span>([methodStr isEqualToString:methodName])</span><br><span class="line">            &#123;</span><br><span class="line">                lastImp = method_getImplementation(method);</span><br><span class="line">                lastSel = method_getName(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">void</span> (*fn)(<span class="keyword">id</span>,SEL);</span><br><span class="line">        <span class="keyword">if</span> (lastImp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fn f = (fn)lastImp;</span><br><span class="line">            f(cls,lastSel);</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（十）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/30/iOS小知识（十）/" class="article-date">
  	<time datetime="2018-10-30T04:44:55.000Z" itemprop="datePublished">2018-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/30/iOS小知识（十）/"> iOS小知识（十）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-_macOS_u5347_u7EA7_uFF0C_u65E0_u6CD5pull_u8FDC_u7AEF_u4EE3_u7801_3A"><a href="#1-_macOS_u5347_u7EA7_uFF0C_u65E0_u6CD5pull_u8FDC_u7AEF_u4EE3_u7801_3A" class="headerlink" title="1. macOS升级，无法pull远端代码:"></a>1. macOS升级，无法pull远端代码:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Unable to negotiate with "</span>xxx<span class="string">" port "</span>xxx<span class="string">": no matching cipher found. Their offer: aes128-cbc, 3des-cbc, blowfish-cbc, cast128-cbc, arcfour, aes192-cbc, aes256-cbc, rijndael-cbc</span></span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>sudo nano /etc/ssh/ssh_config</p>
<p>将<strong>Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc</strong>的注释去掉</p>
<h3 id="2-_Xcode_10__u62A5_u9519"><a href="#2-_Xcode_10__u62A5_u9519" class="headerlink" title="2. Xcode 10 报错"></a>2. Xcode 10 报错</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library not found <span class="keyword">for</span> -lstdc++</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p><strong>将C++ standard  library中的 CLANG_CXX_LIBRARY改成 libc++</strong></p>
<h3 id="3-_Xcode_u65E0_u7EBF_u8C03_u8BD5"><a href="#3-_Xcode_u65E0_u7EBF_u8C03_u8BD5" class="headerlink" title="3. Xcode无线调试"></a>3. Xcode无线调试</h3><ol>
<li>将iPhone与电脑连接</li>
<li>在window菜单中选择 devices and simulations</li>
<li>选择connect via network，界面不关闭</li>
<li>断开iPhone和电脑连接</li>
<li>在步骤3的界面中，右击设备，选择connect via IP Address</li>
<li>完成</li>
</ol>
<p><strong>对于未在调试状态的手机，我们可以通过debug菜单的attach process by pid or name 来调试断点</strong> </p>
<h3 id="4-__u56FE_u7247_u4E0B_u62C9/_u4E0A_u6ED1_u5173_u95ED"><a href="#4-__u56FE_u7247_u4E0B_u62C9/_u4E0A_u6ED1_u5173_u95ED" class="headerlink" title="4. 图片下拉/上滑关闭"></a>4. 图片下拉/上滑关闭</h3><ol>
<li>使用UICollectionView作为图片浏览器的容器</li>
<li>每个cell作为图片操作的单元</li>
<li>cell中包含一个container(UIScrollView)作为<em>缩放和滑动处理</em>的单元，contentView作为显示单元</li>
<li>container中包含一个显示图片的imageView，contentView中包含一个运动的doingView用于显示<em>缩放和滑动处理</em></li>
<li>当<em>缩放和滑动处理</em>时，doingView 替代原图/缩略图 显示</li>
</ol>
<h3 id="5-__u5173_u8054_u5F15_u7528"><a href="#5-__u5173_u8054_u5F15_u7528" class="headerlink" title="5. 关联引用"></a>5. 关联引用</h3><p>在OC中，关联对象都由AssociationsManager管理。AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对（key-属性，value-属性值）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> OSSpinLock _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;               <span class="comment">// associative references:  object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（九）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/11/iOS小知识（九）/" class="article-date">
  	<time datetime="2018-10-11T03:15:15.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/11/iOS小知识（九）/">iOS小知识（九）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u4E09_u65B9_u767B_u5F55"><a href="#u4E09_u65B9_u767B_u5F55" class="headerlink" title="三方登录"></a>三方登录</h3><ul>
<li>注册第三方应用的AppID</li>
<li>添加第三方SDK及其所需系统依赖库</li>
<li>在Targets-&gt;Info-&gt;URL Types添加各自的URL Schemes</li>
<li>在info.plist添加LSApplicationQueriesSchemes字段并添加白名单</li>
<li>在AppDelegate中初始化，各自回调，实现代理</li>
</ul>
<p><strong>同一开发者账号下，QQ登录绑定同一ID，需要申请。微信登录不需要</strong></p>
<h3 id="Home_Screen_Quick_Actions"><a href="#Home_Screen_Quick_Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h3><ol>
<li>在appDelegate中创建我们需要的<code>UIApplicationShortcutItem</code>：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithType:(<span class="built_in">NSString</span> *)type localizedTitle:(<span class="built_in">NSString</span> *)localizedTitle localizedSubtitle:(nullable <span class="built_in">NSString</span> *)localizedSubtitle icon:(nullable <span class="built_in">UIApplicationShortcutIcon</span> *)icon userInfo:(nullable <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span> &lt;<span class="built_in">NSSecureCoding</span>&gt;&gt; *)userInfo <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure>
<p>其中type和title是必须要有的，type表示该shortcutItem的唯一标识符，title表示在屏幕上显示的标题。并将创建好的shortcutItem添加到<code>[UIApplication sharedApplication].shortcutItems</code></p>
<ol>
<li>在appdelegate中实现方法：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler</span><br></pre></td></tr></table></figure>
<p>根据shortcutItem.type来确定具体的shortcutItem，并将其要实现的功能实现。</p>
<h3 id="Peek__26amp_3B_Pop"><a href="#Peek__26amp_3B_Pop" class="headerlink" title="Peek &amp; Pop"></a>Peek &amp; Pop</h3><ol>
<li><p>注册Peek &amp; Pop 代理</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)registerForPreviewingWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewingDelegate</span>&gt;)delegate sourceView:(<span class="built_in">UIView</span> *)sourceView <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Peek方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Pop方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Peek_u4E0A_u6ED1"><a href="#Peek_u4E0A_u6ED1" class="headerlink" title="Peek上滑"></a>Peek上滑</h3><ol>
<li><p>override对应ViewController的<code>- (NSArray&lt;**id**&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems</code>方法</p>
</li>
<li><p>在该方法中，创建我们需要的<code>UIPreviewAction</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)actionWithTitle:(<span class="built_in">NSString</span> *)title style:(<span class="built_in">UIPreviewActionStyle</span>)style handler:(<span class="keyword">void</span> (^)(<span class="built_in">UIPreviewAction</span> *action, <span class="built_in">UIViewController</span> *previewViewController))handler;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将创建的<code>UIPreviewAction</code>组成NSArray返回</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（八）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/10/iOS小知识（八）/" class="article-date">
  	<time datetime="2018-09-10T08:28:11.000Z" itemprop="datePublished">2018-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/10/iOS小知识（八）/">iOS小知识（八）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>屏幕旋转</p>
<p>需要保持APP整体为UIDeviceOrientationPortrait，部分ViewController（如视频ViewController）可旋转时。我们可以在AppDelegate里将iPhone的supportedInterfaceOrientations设为UIInterfaceOrientationMaskAllButUpsideDown</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(nullable <span class="built_in">UIWindow</span> *)window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice] wbt_isIPad])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们还需要将UIViewController的<code>supportedInterfaceOrientations</code>方法hook住，method swizzling成我们自己的<code>sp_supportedInterfaceOrientations</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)sp_supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UINavigationController</span> class]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> [[(<span class="built_in">UINavigationController</span> *)<span class="keyword">self</span> topViewController] supportedInterfaceOrientations];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UITabBarController</span> class]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> [[(<span class="built_in">UITabBarController</span> *)<span class="keyword">self</span> selectedViewController] supportedInterfaceOrientations];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice] wbt_is<span class="built_in">UIUserInterfaceIdiomPad</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> sp_supportedInterfaceOrientations];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMTime为了解决float 的不准确性.</p>
</li>
<li><p>父类在h文件中实现的protocol ，子类也能继承。</p>
</li>
<li><p>用户账号/密码这类的敏感信息可以存在系统的keychain中，用户删除APP也不会删除keychain中的密码。同一公司的APP可以用keychain group打通</p>
</li>
<li><p>AOP（面向切面编程）可以 基于protocol 也可以 基于runtime。AOP实际上是把某些方法的功能，抽出来，形成一个单独的方法（切面）</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GET和POST的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/22/GET和POST的区别/" class="article-date">
  	<time datetime="2018-08-22T02:45:09.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/GET和POST的区别/">GET和POST的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>GET</strong>：幂等，只读的操作，他除了返回结果之外，不会产生副作用。因此大部分get请求能被CDN缓存，从而大大减少web server的负担</p>
<p>CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现</p>
<p>网站接入CDN后，构建了CDN网络，这个CDN网络一般是由一个DNS服务器和几台缓存服务器运行起来的。 接入CDN后，用户想要获取服务器内容，智能DNS负载均衡会将位于用户最近速度最快的节点返回给用户，用户以最短的时间获取到想要的内容，即提升了用户体验，又减少了对源服务器的资源占用</p>
<p><strong>POST</strong>：非幂等，有副作用的操作。</p>
<p><strong>REST</strong>: URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p>
<p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ul>
<li><p>GET</p>
<p>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F" target="_blank" rel="external">Web Application</a>中。其中一个原因是GET可能会被<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E8%9C%98%E8%9B%9B" target="_blank" rel="external">网络蜘蛛</a>等随意访问。参见<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95" target="_blank" rel="external">安全方法</a></p>
</li>
<li><p>HEAD</p>
<p>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p>
</li>
<li><p>POST</p>
<p>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p>
</li>
<li><p>PUT</p>
<p>向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE</p>
<p>请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>TRACE</p>
<p>回显服务器收到的请求，主要用于测试或诊断。</p>
</li>
<li><p>OPTIONS</p>
<p>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
<li><p>CONNECT</p>
<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（七）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/09/iOS小知识（七）/" class="article-date">
  	<time datetime="2018-08-09T09:59:25.000Z" itemprop="datePublished">2018-08-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/09/iOS小知识（七）/">iOS小知识（七）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001_u79BB_u5C4F_u6E32_u67D3"><a href="#u4E00_u3001_u79BB_u5C4F_u6E32_u67D3" class="headerlink" title="一、离屏渲染"></a>一、离屏渲染</h4><p>离屏渲染 包含两类 CPU离屏渲染和GPU离屏渲染</p>
<p>一般意义上的“离屏渲染”是指GPU离屏渲染：在GPU中屏幕外context生成一个buffer，用来渲染不能直接在屏幕上进行绘制的图层。当图层合并成为一个屏幕能直接绘制的图层后，buffer 将合成后的图层交给 frame buffer 由屏幕内context进行绘制。因为涉及到GPU context 的切换，所以会导致屏幕绘制时间变长，从而引起丢帧，导致卡顿。</p>
<p>CPU离屏渲染是由Core Graphics 框架造成的，并不是一般意义上的“离屏渲染”。当使用drawRect/CG 进行绘图时，实际上是使用CPU进行同步绘制。当绘制一些简单图形时，CPU占用的时间 &lt; GPU上下文转换的时间，在这种情况下，我们可以考虑CG的离屏渲染。</p>
<p>shouldRasterize 会引发GPU离屏渲染，但是只要光栅化图层的子图层不改变，那么光栅化会被缓存并在每帧进行绘制。</p>
<h4 id="u4E8C_u3001UITabBarController_u5224_u65AD_u662F_u5426_u8DF3_u8F6C"><a href="#u4E8C_u3001UITabBarController_u5224_u65AD_u662F_u5426_u8DF3_u8F6C" class="headerlink" title="二、UITabBarController判断是否跳转"></a>二、UITabBarController判断是否跳转</h4><p>可以使用<code>tabBarController: shouldSelectViewController:</code>方法，能跳转的tabBar返回YES，否则返回NO</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)tabBarController:(<span class="built_in">UITabBarController</span> *)tabBarController shouldSelectViewController:(<span class="built_in">UIViewController</span> *)viewController</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (tabBarController<span class="variable">.tabBar</span><span class="variable">.selectedItem</span><span class="variable">.tag</span>==<span class="number">3</span>) </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4E09_u3001performSelector_3A_u548CNSInvocation"><a href="#u4E09_u3001performSelector_3A_u548CNSInvocation" class="headerlink" title="三、performSelector:和NSInvocation"></a>三、<code>performSelector:</code>和<code>NSInvocation</code></h4><p>直接调用对象有 performSelector 和 NSInvocation 两种方式。但是performSelector 最多支持一个参数，若需要多参数，需要使用 NSInvocation。其使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)invocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法签名</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(calWith:andB:)];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (signature) &#123;</span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">        invocation<span class="variable">.target</span> = <span class="keyword">self</span>;</span><br><span class="line">        invocation<span class="variable">.selector</span> = <span class="keyword">@selector</span>(calWith:andB:);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">        <span class="comment">//自定义参数索引从2开始（atIndex），0，1 被target、selector占用</span></span><br><span class="line">        [invocation setArgument:&amp;a atIndex:<span class="number">2</span>];</span><br><span class="line">        [invocation setArgument:&amp;b atIndex:<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">void</span>)calWith:(<span class="keyword">int</span>)a andB:(<span class="keyword">int</span>) b</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"result:%zd"</span>,a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u56DB_u3001NSSet_u548CNSArray"><a href="#u56DB_u3001NSSet_u548CNSArray" class="headerlink" title="四、NSSet和NSArray"></a>四、NSSet和NSArray</h4><h5 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h5><p>自定义对象加入NSSet中，需要重写<code>isEqual:</code>和<code>hash</code>方法。同一对象add到set中，只能add一次。</p>
<h5 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h5><p>同一对象add到array中，可以add多次。但是remove同一对象时，所有对象都被remove。</p>
<p>对两个array求 交集、并集、差集，可以先将array转为set，然后使用set的 <code>intersectSet:</code> 、  <code>unionSet:</code> 、<code>minusSet:</code>方法。最后将set转回array</p>
<h4 id="u4E94_u3001_u81EA_u5B9A_u4E49cell"><a href="#u4E94_u3001_u81EA_u5B9A_u4E49cell" class="headerlink" title="五、自定义cell"></a>五、自定义cell</h4><p>当cell不可编辑时，<code>[self addSubview:view]</code> 和<code>[self.contentView addSubview:view]</code> 无区别</p>
<p>当cell可编辑时，使用<code>[self.contentView addSubview:view]</code> ，<code>[self addSubview:view]</code> 会导致布局错乱</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-代码规范" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/25/代码规范/" class="article-date">
  	<time datetime="2018-07-25T02:48:02.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/25/代码规范/">代码规范</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_Yoda_conditions"><a href="#1-_Yoda_conditions" class="headerlink" title="1. Yoda conditions"></a>1. Yoda conditions</h2><p> <strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value == <span class="number">6</span>) &#123; ...</span><br></pre></td></tr></table></figure>
<p> <strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">6</span> == value) &#123; ...</span><br></pre></td></tr></table></figure>
<h2 id="2-_nil_u548CBOOL_u68C0_u67E5"><a href="#2-_nil_u548CBOOL_u68C0_u67E5" class="headerlink" title="2. nil和BOOL检查"></a>2. nil和BOOL检查</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject) &#123; ...</span><br><span class="line"><span class="keyword">if</span> (![someObject boolValue]) &#123; ...</span><br><span class="line"><span class="keyword">if</span> (!someObject) &#123; ...</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject == <span class="literal">YES</span>) &#123; ... <span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (myRawValue == <span class="literal">YES</span>) &#123; ... <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> ([someObject boolValue] == <span class="literal">NO</span>) &#123; ...</span><br></pre></td></tr></table></figure>
<h2 id="3-_Golden_Path"><a href="#3-_Golden_Path" class="headerlink" title="3. Golden Path"></a>3. Golden Path</h2><p> <strong>推荐:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-__u590D_u6742_u8868_u8FBE_u5F0F"><a href="#4-__u590D_u6742_u8868_u8FBE_u5F0F" class="headerlink" title="4. 复杂表达式"></a>4. 复杂表达式</h2><p> <strong>推荐:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isA = [str1 isEqualToString:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isB = [str2 isEqualToString:<span class="string">@"b"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isC = [str3 isEqualToString:<span class="string">@"c"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> isStrEqual = isA &amp;&amp; isB &amp;&amp; isC;</span><br><span class="line"><span class="keyword">if</span> (isStrEqual)&#123;</span><br><span class="line">    <span class="comment">// Do something very cool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([str1 isEqualToString:<span class="string">@"a"</span>] &amp;&amp; [str2 isEqualToString:<span class="string">@"b"</span>] &amp;&amp; [str3 isEqualToString:<span class="string">@"c"</span>];)&#123;</span><br><span class="line">    <span class="comment">// Do something very cool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-__u4E09_u5143_u8FD0_u7B97_u7B26"><a href="#5-__u4E09_u5143_u8FD0_u7B97_u7B26" class="headerlink" title="5. 三元运算符"></a>5. 三元运算符</h2><p><strong>推荐:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 = a &gt; b ? x : y;</span><br><span class="line">result2 = object ? : [<span class="keyword">self</span> createObject];</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 = a &gt; b ? x = c &gt; d ? c : d : y;</span><br><span class="line">result2 = object ? object : [<span class="keyword">self</span> createObject];</span><br></pre></td></tr></table></figure>
<h2 id="6-_CGRect_u51FD_u6570"><a href="#6-_CGRect_u51FD_u6570" class="headerlink" title="6. CGRect函数"></a>6. CGRect函数</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame); </span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame); </span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame); </span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame); </span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> x = frame<span class="variable">.origin</span><span class="variable">.x</span>;  </span><br><span class="line"><span class="built_in">CGFloat</span> y = frame<span class="variable">.origin</span><span class="variable">.y</span>;  </span><br><span class="line"><span class="built_in">CGFloat</span> width = frame<span class="variable">.size</span><span class="variable">.width</span>;  </span><br><span class="line"><span class="built_in">CGFloat</span> height = frame<span class="variable">.size</span><span class="variable">.height</span>;  </span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; <span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = frame<span class="variable">.size</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-__u5B57_u9762_u503C"><a href="#7-__u5B57_u9762_u503C" class="headerlink" title="7. 字面值"></a>7. 字面值</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span> : <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span> : <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span> : <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingZIPCode = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingZIPCode = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<h2 id="8-__u5C5E_u6027"><a href="#8-__u5C5E_u6027" class="headerlink" title="8. 属性"></a>8. 属性</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *text;</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* text;</span><br><span class="line"><span class="built_in">NSString</span> * text;</span><br></pre></td></tr></table></figure>
<h2 id="9-__u65B9_u6CD5_u540D"><a href="#9-__u65B9_u6CD5_u540D" class="headerlink" title="9. 方法名"></a>9. 方法名</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)classMethod;</span><br><span class="line">- (<span class="keyword">void</span>)instanceMethod</span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)classMethod;</span><br><span class="line">-(<span class="keyword">void</span>)instanceMethod</span><br></pre></td></tr></table></figure>
<h2 id="10-__u70B9_u8BED_u6CD5"><a href="#10-__u70B9_u8BED_u6CD5" class="headerlink" title="10. 点语法"></a>10. 点语法</h2><p><strong>推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];	<span class="comment">//属性</span></span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.delegate</span>;		<span class="comment">//方法</span></span><br></pre></td></tr></table></figure>
<p><strong>不推荐：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span><span class="variable">.delegate</span>;</span><br></pre></td></tr></table></figure>
<h2 id="11-__u65B9_u6CD5_u540D_u524D_u7F00"><a href="#11-__u65B9_u6CD5_u540D_u524D_u7F00" class="headerlink" title="11. 方法名前缀"></a>11. 方法名前缀</h2><ul>
<li>刷新视图的方法名要以<code>refresh</code>开头</li>
<li>更新数据的方法名要以<code>update</code>开头</li>
</ul>
<h2 id="12-_Delegate_u548CDataSource"><a href="#12-_Delegate_u548CDataSource" class="headerlink" title="12. Delegate和DataSource"></a>12. Delegate和DataSource</h2><ul>
<li>delegate:事件发生的时候，委托者需要通知代理者。(<strong>返回值为void</strong>)</li>
<li>datasource: 委托者需要从数据源对象拉取数据。(<strong>返回值不为void</strong>)</li>
</ul>
<h2 id="13-__u6CE8_u91CA"><a href="#13-__u6CE8_u91CA" class="headerlink" title="13. 注释"></a>13. 注释</h2><ul>
<li>单行注释用//</li>
<li>多行注释用/<em> </em>/</li>
</ul>
<h2 id="14-__u5927_u62EC_u53F7"><a href="#14-__u5927_u62EC_u53F7" class="headerlink" title="14. 大括号"></a>14. 大括号</h2><ul>
<li>控制语句使用Egyptian brackets</li>
<li>方法实现使用Non-Egyptian brackets</li>
</ul>
<p><strong>reference：</strong></p>
<p><a href="https://github.com/objc-zen/objc-zen-book" target="_blank" rel="external">objc zen book</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/23/iOS-Core-Animation-Advanced-Techniques阅读笔记（三）/" class="article-date">
  	<time datetime="2018-07-23T13:04:40.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/iOS-Core-Animation-Advanced-Techniques阅读笔记（三）/">iOS Core Animation Advanced Techniques阅读笔记（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u6027_u80FD_u8C03_u4F18"><a href="#u4E00_u3001_u6027_u80FD_u8C03_u4F18" class="headerlink" title="一、性能调优"></a>一、性能调优</h1><h2 id="1-1_CPU_VS_GPU"><a href="#1-1_CPU_VS_GPU" class="headerlink" title="1.1 CPU VS GPU"></a>1.1 CPU VS GPU</h2><p>GPU使用图像对高度并行浮点运算做了优化。GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）</p>
<h3 id="1-1-1__u52A8_u753B_u7684_u821E_u53F0"><a href="#1-1-1__u52A8_u753B_u7684_u821E_u53F0" class="headerlink" title="1.1.1 动画的舞台"></a>1.1.1 动画的舞台</h3><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的<em>渲染服务</em>（<strong>render server</strong>）。</p>
<p>当运行一段动画时候，这个过程会被四个分离的阶段被打破：</p>
<ul>
<li><strong>布局</strong> - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。（<strong>开发者控制</strong>）</li>
<li><strong>显示</strong> - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>方法的调用路径。（<strong>开发者控制</strong>）</li>
<li><strong>准备</strong> - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li>
<li><strong>提交</strong> - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li>
</ul>
<p>一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<strong>渲染树</strong>的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p>
<ul>
<li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li>
<li>在屏幕上渲染可见的三角形（<strong>GPU处理</strong>）</li>
</ul>
<h3 id="1-1-2_GPU_u76F8_u5173_u7684_u64CD_u4F5C"><a href="#1-1-2_GPU_u76F8_u5173_u7684_u64CD_u4F5C" class="headerlink" title="1.1.2 GPU相关的操作"></a>1.1.2 GPU相关的操作</h3><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。</p>
<p>宽泛的说，大多数<code>CALayer</code>的属性都是用GPU来绘制。</p>
<p>降低（基于GPU）图层绘制的操作：</p>
<ol>
<li><strong>太多的几何结构</strong> - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。在Core Animation中几何结构并不是GPU的瓶颈所在，但由于图层在显示之前通过IPC发送到渲染服务器的时候，太多的图层就会引起CPU的瓶颈。</li>
<li><strong>重绘</strong> - 主要由重叠的半透明图层引起。GPU的<em>填充比率</em>（用颜色填充像素的比率）是有限的，所以需要避免<em>重绘</em>（每一帧用相同的像素填充多次）的发生。</li>
<li><strong>离屏绘制</strong> - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。</li>
<li><strong>过大的图片</strong> - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</li>
</ol>
<h3 id="1-1-3_CPU_u76F8_u5173_u7684_u64CD_u4F5C"><a href="#1-1-3_CPU_u76F8_u5173_u7684_u64CD_u4F5C" class="headerlink" title="1.1.3 CPU相关的操作"></a>1.1.3 CPU相关的操作</h3><p>在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p>
<p> 以下CPU的操作都会延迟动画的开始时间：</p>
<ul>
<li><strong>布局计算</strong> - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。</li>
<li><strong>视图惰性加载</strong> - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。</li>
<li><strong>Core Graphics绘制</strong> - 如果对视图实现了<code>-drawRect:</code>方法，或者<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢。</li>
<li><strong>解压图片</strong> - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用<code>UIImageView</code>）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li>
</ul>
<h2 id="1-2_Instruments"><a href="#1-2_Instruments" class="headerlink" title="1.2 Instruments"></a>1.2 Instruments</h2><ul>
<li><strong>时间分析器</strong> - 用来测量被方法/函数打断的CPU使用情况。</li>
<li><strong>Core Animation</strong> - 用来调试各种Core Animation性能问题。</li>
<li><strong>OpenGL ES驱动</strong> - 用来调试GPU性能问题。这个工具在编写Open GL代码的时候很有用，但有时也用来处理Core Animation的工作。</li>
</ul>
<p>Core Animation工具也提供了一系列复选框选项来帮助调试渲染瓶颈：</p>
<ul>
<li><strong>Color Blended Layers</strong> - 这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮（也就是多个半透明图层的叠加）。由于重绘的原因，混合对GPU性能会有影响，同时也是滑动或者动画帧率下降的罪魁祸首之一。</li>
<li><strong>ColorHitsGreenandMissesRed</strong> - 当使用<code>shouldRasterized</code>属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存再生的时候这个选项就用红色对栅格化图层进行了高亮。如果缓存频繁再生的话，就意味着栅格化可能会有负面的性能影响了。</li>
<li><strong>Color Copied Images</strong> - 有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</li>
<li><strong>Color Immediately</strong> - 通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>
<li><strong>Color Misaligned Images</strong> - 这里会高亮那些被缩放或者拉伸以及没有正确对齐到像素边界的图片（也就是非整型坐标）。这些中的大多数通常都会导致图片的不正常缩放，如果把一张大图当缩略图显示，或者不正确地模糊图像，那么这个选项将会帮你识别出问题所在。</li>
<li><strong>Color Offscreen-Rendered Yellow</strong> - 这里会把那些需要离屏渲染的图层高亮成黄色。这些图层很可能需要用<code>shadowPath</code>或者<code>shouldRasterize</code>来优化。</li>
<li><strong>Color OpenGL Fast Path Blue</strong> - 这个选项会对任何直接使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animation的API，那么不会有任何效果。如果使用<code>GLKView</code>或者<code>CAEAGLLayer</code>，那如果不显示蓝色块的话就意味着你正在强制CPU渲染额外的纹理，而不是绘制到屏幕。</li>
<li><strong>Flash Updated Regions</strong> - 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。</li>
</ul>
<h1 id="u4E8C_u3001_u9AD8_u6548_u7ED8_u56FE"><a href="#u4E8C_u3001_u9AD8_u6548_u7ED8_u56FE" class="headerlink" title="二、高效绘图"></a>二、高效绘图</h1><h2 id="2-1__u8F6F_u4EF6_u7ED8_u56FE"><a href="#2-1__u8F6F_u4EF6_u7ED8_u56FE" class="headerlink" title="2.1 软件绘图"></a>2.1 软件绘图</h2><p>在iOS中，软件绘图通常是由Core Graphics框架完成来完成。但是，在一些必要的情况下，相比Core Animation和OpenGL，Core Graphics要慢了不少。</p>
<p>软件绘图不仅效率低，还会消耗可观的内存。<code>CALayer</code>只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。</p>
<p>但是一旦你实现了<code>CALayerDelegate</code>协议中的<code>-drawLayer:inContext:</code>方法或者<code>UIView</code>中的<code>-drawRect:</code>方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽<em>图层高</em>4字节，宽高的单位均为像素。</p>
<p>提高绘制性能的秘诀就在于尽量避免去绘制。</p>
<h2 id="2-2__u77E2_u91CF_u56FE_u5F62"><a href="#2-2__u77E2_u91CF_u56FE_u5F62" class="headerlink" title="2.2 矢量图形"></a>2.2 矢量图形</h2><p>我们用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能轻易地绘制出矢量图形。矢量绘图包含一下这些：</p>
<ul>
<li>任意多边形（不仅仅是一个矩形）</li>
<li>斜线或曲线</li>
<li>文本</li>
<li>渐变</li>
</ul>
<p>Core Animation为这些图形类型的绘制提供了专门的类，并给他们提供硬件支持。</p>
<ul>
<li><p><code>CAShapeLayer</code>可以绘制多边形，直线和曲线。</p>
</li>
<li><p><code>CATextLayer</code>可以绘制文本。</p>
</li>
<li><p><code>CAGradientLayer</code>用来绘制渐变。这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。</p>
</li>
</ul>
<h2 id="2-3__u810F_u77E9_u5F62"><a href="#2-3__u810F_u77E9_u5F62" class="headerlink" title="2.3 脏矩形"></a>2.3 脏矩形</h2><p>为了减少不必要的绘制，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而这个位置就是『脏矩形』。</p>
<p>当你检测到指定视图或图层的指定部分需要被重绘，你直接调用<code>-setNeedsDisplayInRect:</code>来标记它，然后将影响到的矩形作为参数传入。这样就会在一次视图刷新时调用视图的<code>-drawRect:</code>（或图层代理的<code>-drawLayer:inContext:</code>方法）。</p>
<p>传入<code>-drawLayer:inContext:</code>的<code>CGContext</code>参数会自动被裁切以适应对应的矩形。为了确定矩形的尺寸大小，你可以用<code>CGContextGetClipBoundingBox()</code>方法来从上下文获得大小。调用<code>-drawRect()</code>会更简单，因为<code>CGRect</code>会作为参数直接传入。</p>
<h2 id="2-4__u5F02_u6B65_u7ED8_u5236"><a href="#2-4__u5F02_u6B65_u7ED8_u5236" class="headerlink" title="2.4 异步绘制"></a>2.4 异步绘制</h2><p> <code>CATiledLayer</code>除了将图层再次分割成独立更新的小块（类似于脏矩形自动更新的概念），<code>CATiledLayer</code>还有一个特性：在多个线程中为每个小块同时调用<code>-drawLayer:inContext:</code>方法。</p>
<p><code>drawsAsynchronously</code>属性对传入<code>-drawLayer:inContext:</code>的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。</p>
<p> <code>drawsAsynchronously</code>与<code>CATiledLayer</code>使用的异步绘制并不相同。它自己的<code>-drawLayer:inContext:</code>方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。</p>
<h1 id="u4E09_u3001_u56FE_u50CFIO"><a href="#u4E09_u3001_u56FE_u50CFIO" class="headerlink" title="三、图像IO"></a>三、图像IO</h1><h2 id="3-1__u52A0_u8F7D_u548C_u6F5C_u4F0F"><a href="#3-1__u52A0_u8F7D_u548C_u6F5C_u4F0F" class="headerlink" title="3.1 加载和潜伏"></a>3.1 加载和潜伏</h2><p> 绘图实际消耗的时间通常并不是影响性能的因素。图片消耗很大一部分内存，而且不太可能把需要显示的图片都保留在内存中，所以需要在应用运行的时候周期性地加载和卸载图片。</p>
<h3 id="3-1-1__u7EBF_u7A0B_u52A0_u8F7D"><a href="#3-1-1__u7EBF_u7A0B_u52A0_u8F7D" class="headerlink" title="3.1.1 线程加载"></a>3.1.1 线程加载</h3><p>滑动动画会在主线程的run loop中更新，它们是在渲染服务进程中运行的，并因此更容易比CAAnimation遭受CPU相关的性能问题。</p>
<h3 id="3-1-2_GCD_u548CNSOperationQueue"><a href="#3-1-2_GCD_u548CNSOperationQueue" class="headerlink" title="3.1.2 GCD和NSOperationQueue"></a>3.1.2 GCD和<code>NSOperationQueue</code></h3><p>GCD（Grand Central Dispatch）和<code>NSOperationQueue</code>很类似，都给我们提供了队列闭包块来在线程中按一定顺序来执行。<code>NSOperationQueue</code>有一个Objecive-C接口（而不是使用GCD的全局C函数），同样在操作优先级和依赖关系上提供了很好的粒度控制，但是需要更多地设置代码。</p>
<h3 id="3-1-3__u5EF6_u8FDF_u89E3_u538B"><a href="#3-1-3__u5EF6_u8FDF_u89E3_u538B" class="headerlink" title="3.1.3 延迟解压"></a>3.1.3 延迟解压</h3><p> 用于加载的CPU时间相对于解码来说根据图片格式而不同。对于PNG图片来说，加载会比JPEG更长，因为文件可能更大，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为JPEG解压算法比基于zip的PNG算法更加复杂。</p>
<p>当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。</p>
<p>有两种方式可以为强制解压提前渲染图片：</p>
<ol>
<li>将图片的一个像素绘制成一个像素大小的<code>CGContext</code>。这样仍然会解压整张图片，但是绘制本身并没有消耗任何时间。这样的好处在于加载的图片并不会在特定的设备上为绘制做优化，所以可以在任何时间点绘制出来。同样iOS也就可以丢弃解压后的图片来节省内存了。</li>
<li>张图片绘制到<code>CGContext</code>中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素那样需要更加复杂的计算，但是因此产生的图片将会为绘制做优化，而且由于原始压缩图片被抛弃了，iOS就不能够随时丢弃任何解压后的图片来节省内存了。</li>
</ol>
<h3 id="3-1-4_CATiledLayer"><a href="#3-1-4_CATiledLayer" class="headerlink" title="3.1.4  CATiledLayer"></a>3.1.4  <code>CATiledLayer</code></h3><p> <code>CATiledLayer</code>可以用来异步加载和显示大型图片，而不阻塞用户输入。</p>
<h3 id="3-1-5__u5206_u8FA8_u7387_u4EA4_u6362"><a href="#3-1-5__u5206_u8FA8_u7387_u4EA4_u6362" class="headerlink" title="3.1.5 分辨率交换"></a>3.1.5 分辨率交换</h3><p> 如果需要快速加载和显示移动大图，简单的办法就是欺骗人眼，在移动传送器的时候显示一个小图（或者低分辨率），然后当停止的时候再换成大图。</p>
<h2 id="3-2__u7F13_u5B58"><a href="#3-2__u7F13_u5B58" class="headerlink" title="3.2 缓存"></a>3.2 缓存</h2><p>缓存其实很简单：就是将昂贵计算后的结果（或者是从闪存或者网络加载的文件）存储到内存中，以便后续使用，这样访问起来很快。问题在于缓存本质上是一个权衡过程 - 为了提升性能而消耗了内存，但是由于内存是一个非常宝贵的资源，所以不能把所有东西都做缓存。</p>
<h3 id="3-2-1_+imageNamed_3A_u65B9_u6CD5"><a href="#3-2-1_+imageNamed_3A_u65B9_u6CD5" class="headerlink" title="3.2.1 +imageNamed:方法"></a>3.2.1 <code>+imageNamed:</code>方法</h3><p><code>[UIImage imageNamed:]</code>加载图片有个好处在于可以立刻解压图片而不用等到绘制的时候。但是<code>[UIImage imageNamed:]</code>方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。</p>
<ul>
<li><code>[UIImage imageNamed:]</code>方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以<code>[UIImage imageNamed:]</code>就没法用了。</li>
<li><code>[UIImage imageNamed:]</code>缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。</li>
<li><code>[UIImage imageNamed:]</code>缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。</li>
</ul>
<h3 id="3-2-2__u81EA_u5B9A_u4E49_u7F13_u5B58"><a href="#3-2-2__u81EA_u5B9A_u4E49_u7F13_u5B58" class="headerlink" title="3.2.2 自定义缓存"></a>3.2.2 自定义缓存</h3><ul>
<li>选择一个合适的缓存键 - 缓存键用来做图片的唯一标识。如果实时创建图片，通常不太好生成一个字符串来区分别的图片。在我们的图片传送带例子中就很简单，我们可以用图片的文件名或者表格索引。</li>
<li>提前缓存 - 如果生成和加载数据的代价很大，你可能想当第一次需要用到的时候再去加载和缓存。提前加载的逻辑是应用内在就有的，但是在我们的例子中，这也非常好实现，因为对于一个给定的位置和滚动方向，我们就可以精确地判断出哪一张图片将会出现。</li>
<li>缓存失效 - 如果图片文件发生了变化，怎样才能通知到缓存更新呢？这是个非常困难的问题（就像菲尔 卡尔顿提到的），但是幸运的是当从程序资源加载静态图片的时候并不需要考虑这些。对用户提供的图片来说（可能会被修改或者覆盖），一个比较好的方式就是当图片缓存的时候打上一个时间戳以便当文件更新的时候作比较。</li>
<li>缓存回收 - 当内存不够的时候，如何判断哪些缓存需要清空呢？这就需要到你写一个合适的算法了。幸运的是，对缓存回收的问题，苹果提供了一个叫做<code>NSCache</code>通用的解决方案</li>
</ul>
<h3 id="3-2-3_NSCache"><a href="#3-2-3_NSCache" class="headerlink" title="3.2.3 NSCache"></a>3.2.3 NSCache</h3><p><code>NSCache</code>和<code>NSDictionary</code>类似。你可以通过<code>-setObject:forKey:</code>和<code>-object:forKey:</code>方法分别来插入，检索。和字典不同的是，<code>NSCache</code>在系统低内存的时候自动丢弃存储的对象。</p>
<h2 id="3-3__u6587_u4EF6_u683C_u5F0F"><a href="#3-3__u6587_u4EF6_u683C_u5F0F" class="headerlink" title="3.3 文件格式"></a>3.3 文件格式</h2><p> PNG和JPEG压缩算法作用于两种不同的图片类型：JPEG对于噪点大的图片效果很好；但是PNG更适合于扁平颜色，锋利的线条或者一些渐变色的图片。</p>
<h1 id="u56DB_u3001__u56FE_u5C42_u6027_u80FD"><a href="#u56DB_u3001__u56FE_u5C42_u6027_u80FD" class="headerlink" title="四、 图层性能"></a>四、 图层性能</h1><h2 id="4-1__u9690_u5F0F_u7ED8_u5236"><a href="#4-1__u9690_u5F0F_u7ED8_u5236" class="headerlink" title="4.1 隐式绘制"></a>4.1 隐式绘制</h2><p> 寄宿图可以通过Core Graphics直接绘制，也可以直接载入一个图片文件并赋值给<code>contents</code>属性，或事先绘制一个屏幕之外的<code>CGContext</code>上下文。除了常见的显式创建寄宿图，你也可以通过以下三种方式创建隐式的：</p>
<ol>
<li>使用特性的图层属性</li>
<li>特定的视图</li>
<li>特定的图层子类</li>
</ol>
<h3 id="4-1-1__u6587_u672C"><a href="#4-1-1__u6587_u672C" class="headerlink" title="4.1.1 文本"></a>4.1.1 文本</h3><p><code>CATextLayer</code>和<code>UILabel</code>都是直接将文本绘制在图层的寄宿图中。尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文本就需要重绘。</p>
<h3 id="4-1-2__u5149_u6805_u5316"><a href="#4-1-2__u5149_u6805_u5316" class="headerlink" title="4.1.2 光栅化"></a>4.1.2 光栅化</h3><p>启用<code>shouldRasterize</code>属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的<code>contents</code>和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。</p>
<h2 id="4-2__u79BB_u5C4F_u6E32_u67D3"><a href="#4-2__u79BB_u5C4F_u6E32_u67D3" class="headerlink" title="4.2 离屏渲染"></a>4.2 离屏渲染</h2><p> 当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。图层的以下属性将会触发屏幕外绘制：</p>
<ul>
<li>圆角（当和<code>maskToBounds</code>一起使用时）</li>
<li>图层蒙板</li>
<li>阴影</li>
</ul>
<h3 id="4-2-1_CAShapeLayer"><a href="#4-2-1_CAShapeLayer" class="headerlink" title="4.2.1 CAShapeLayer"></a>4.2.1 CAShapeLayer</h3><p><code>cornerRadius</code>和<code>maskToBounds</code>独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候你想显示圆角并沿着图层裁切子图层的时候，你可能会发现你并不需要沿着圆角裁切，这个情况下用<code>CAShapeLayer</code>就可以避免这个问题了。</p>
<h3 id="4-2-2__u53EF_u4F38_u7F29_u56FE_u7247"><a href="#4-2-2__u53EF_u4F38_u7F29_u56FE_u7247" class="headerlink" title="4.2.2 可伸缩图片"></a>4.2.2 可伸缩图片</h3><p>使用可伸缩图片的优势在于它可以绘制成任意边框效果而不需要额外的性能消耗。</p>
<h3 id="4-2-3_shadowPath"><a href="#4-2-3_shadowPath" class="headerlink" title="4.2.3 shadowPath"></a>4.2.3 shadowPath</h3><p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），创建出一个对应形状的阴影路径就比较容易，而且Core Animation绘制这个阴影也相当简单，避免了屏幕外的图层部分的预排版需求。这对性能来说很有帮助。</p>
<h2 id="4-3__u6DF7_u5408_u548C_u8FC7_u5EA6_u7ED8_u5236"><a href="#4-3__u6DF7_u5408_u548C_u8FC7_u5EA6_u7ED8_u5236" class="headerlink" title="4.3 混合和过度绘制"></a>4.3 混合和过度绘制</h2><p>GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。</p>
<p>GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当可观的。</p>
<ul>
<li>给视图的<code>backgroundColor</code>属性设置一个固定的，不透明的颜色</li>
<li>设置<code>opaque</code>属性为YES</li>
</ul>
<p>如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。</p>
<p>如果是文本的话，一个白色背景的<code>UILabel</code>（或者其他颜色）会比透明背景要更高效。</p>
<p>最后，明智地使用<code>shouldRasterize</code>属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</p>
<p><code>shouldRasterize</code>，它自动地处理缓存和缓存验证</p>
<h2 id="4-4__u51CF_u5C11_u56FE_u5C42_u6570_u91CF"><a href="#4-4__u51CF_u5C11_u56FE_u5C42_u6570_u91CF" class="headerlink" title="4.4 减少图层数量"></a>4.4 减少图层数量</h2><p> 初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成OpenGL几何图形，这些是一个图层的大致资源开销。事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。</p>
<p>处理巨大数量的相似视图或图层时还有一个技巧就是回收他们。</p>
<p>没有与图层树相关联的图层不会被送到渲染引擎，也没有性能问题（在他们被创建和配置之后）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/" class="article-date">
  	<time datetime="2018-07-22T15:21:45.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/">iOS Core Animation Advanced Techniques阅读笔记（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u9690_u5F0F_u52A8_u753B"><a href="#u4E00_u3001_u9690_u5F0F_u52A8_u753B" class="headerlink" title="一、隐式动画"></a>一、隐式动画</h1><h2 id="1-1__u4E8B_u52A1"><a href="#1-1__u4E8B_u52A1" class="headerlink" title="1.1 事务"></a>1.1 事务</h2><p>隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画</p>
<p>动画执行的时间取决于当前<em>事务</em>的设置，动画类型取决于<em>图层行为</em>。</p>
<p>Core Animation在每个<em>run loop</em>周期中自动开始一次新的事务，即使你不显式地使用<code>[CATransaction begin]</code>开始一次事务，在一个特定run loop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。</p>
<h2 id="1-2__u5B8C_u6210_u5757"><a href="#1-2__u5B8C_u6210_u5757" class="headerlink" title="1.2 完成块"></a>1.2 完成块</h2><p>基于<code>UIView</code>的block的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。</p>
<h2 id="1-3__u56FE_u5C42_u884C_u4E3A"><a href="#1-3__u56FE_u5C42_u884C_u4E3A" class="headerlink" title="1.3 图层行为"></a>1.3 图层行为</h2><ul>
<li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li>
<li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li>
</ul>
<h2 id="1-4__u5448_u73B0_u4E0E_u6A21_u578B"><a href="#1-4__u5448_u73B0_u4E0E_u6A21_u578B" class="headerlink" title="1.4 呈现与模型"></a>1.4 呈现与模型</h2><p>设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p>
<p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p>
<p>每个图层属性的显示值都被存储在一个叫做 <strong>呈现图层</strong> 的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p>
<p><strong>呈现树 </strong>通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p>
<p> 两种情况下呈现图层会变得很有用，一个是<strong>同步动画</strong>，一个是处理<strong>用户交互</strong>。</p>
<ul>
<li>如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<h1 id="u4E8C_u3001_u663E_u5F0F_u52A8_u753B"><a href="#u4E8C_u3001_u663E_u5F0F_u52A8_u753B" class="headerlink" title="二、显式动画"></a>二、显式动画</h1><h2 id="2-1__u5C5E_u6027_u52A8_u753B"><a href="#2-1__u5C5E_u6027_u52A8_u753B" class="headerlink" title="2.1 属性动画"></a>2.1 属性动画</h2><p>属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：<em>基础</em>和<em>关键帧</em>。</p>
<p>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是<code>CABasicAnimation</code>最主要的功能。</p>
<p>像所有的<code>NSObject</code>子类一样，<code>CAAnimation</code>实现了KVC（键-值-编码）协议，于是你可以用<code>-setValue:forKey:</code>和<code>-valueForKey:</code>方法来存取属性。但是<code>CAAnimation</code>有一个与众不同的特性：它更像一个<code>NSDictionary</code>，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<h2 id="2-2__u5173_u952E_u5E27_u52A8_u753B"><a href="#2-2__u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="2.2 关键帧动画"></a>2.2 关键帧动画</h2><p><code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code>那样把<code>fromValue</code>设为<code>nil</code>）。</p>
<h2 id="2-3__u865A_u62DF_u5C5E_u6027"><a href="#2-3__u865A_u62DF_u5C5E_u6027" class="headerlink" title="2.3 虚拟属性"></a>2.3 虚拟属性</h2><p><code>transform.rotation</code>而不是<code>transform</code>做动画的好处如下：</p>
<ul>
<li>我们可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置<code>byValue</code>而不是<code>toValue</code>）。</li>
<li>可以不用创建<code>CATransform3D</code>，而是使用一个简单的数值来指定角度。</li>
<li>不会和<code>transform.position</code>或者<code>transform.scale</code>冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<p><code>transform.rotation</code>属性有一个奇怪的问题是它其实<em>并不存在</em>。这是因为<code>CATransform3D</code>并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，<code>transform.rotation</code>实际上是一个<code>CALayer</code>用于处理动画变换的<em>虚拟</em>属性。</p>
<h2 id="2-4__u52A8_u753B_u7EC4"><a href="#2-4__u52A8_u753B_u7EC4" class="headerlink" title="2.4 动画组"></a>2.4 动画组</h2><p><code>CABasicAnimation</code>和<code>CAKeyframeAnimation</code>仅仅作用于单独的属性，而<code>CAAnimationGroup</code>可以把这些动画组合在一起。</p>
<h2 id="2-5__u8FC7_u6E21"><a href="#2-5__u8FC7_u6E21" class="headerlink" title="2.5 过渡"></a>2.5 过渡</h2><p><code>CATransition</code>，同样是另一个<code>CAAnimation</code>的子类，和别的子类不同，<code>CATransition</code>有一个<code>type</code>和<code>subtype</code>来标识变换效果。<code>type</code>属性是一个<code>NSString</code>类型，可以被设置成如下类型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CATransitionFade</span> </span><br><span class="line">k<span class="built_in">CATransitionMoveIn</span> </span><br><span class="line">k<span class="built_in">CATransitionPush</span> </span><br><span class="line">k<span class="built_in">CATransitionReveal</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6__u9690_u5F0F_u8FC7_u6E21"><a href="#2-6__u9690_u5F0F_u8FC7_u6E21" class="headerlink" title="2.6 隐式过渡"></a>2.6 隐式过渡</h2><p><code>CATransision</code>可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。</p>
<h2 id="2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B"><a href="#2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B" class="headerlink" title="2.7 对图层树的动画"></a>2.7 对图层树的动画</h2><p><code>CATransition</code>并不作用于指定的图层属性。</p>
<h2 id="2-8__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#2-8__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="2.8 自定义动画"></a>2.8 自定义动画</h2><p><code>UIView</code>过渡方法中<code>options</code>参数可以由如下常量指定：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlUp</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlDown</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromTop</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromBottom</span></span><br></pre></td></tr></table></figure>
<h2 id="2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B"><a href="#2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B" class="headerlink" title="2.9 在动画过程中取消动画"></a>2.9 在动画过程中取消动画</h2><p>动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<h1 id="u4E09_u3001_u56FE_u5C42_u65F6_u95F4"><a href="#u4E09_u3001_u56FE_u5C42_u65F6_u95F4" class="headerlink" title="三、图层时间"></a>三、图层时间</h1><h2 id="3-1_CAMediaTiming_u534F_u8BAE"><a href="#3-1_CAMediaTiming_u534F_u8BAE" class="headerlink" title="3.1 CAMediaTiming协议"></a>3.1 <code>CAMediaTiming</code>协议</h2><p><code>CAMediaTiming</code>协议定义了在一段动画内用来控制逝去时间的属性的集合，<code>CALayer</code>和<code>CAAnimation</code>都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>
<h2 id="3-2__u76F8_u5BF9_u65F6_u95F4"><a href="#3-2__u76F8_u5BF9_u65F6_u95F4" class="headerlink" title="3.2 相对时间"></a>3.2 相对时间</h2><p> 每次讨论到Core Animation，时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>
<h2 id="3-3_fillMode"><a href="#3-3_fillMode" class="headerlink" title="3.3 fillMode"></a>3.3 <code>fillMode</code></h2><p> <code>fillMode</code>是一个<code>NSString</code>类型，可以接受如下四种常量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAFillModeForwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBackwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBoth</span></span><br><span class="line">k<span class="built_in">CAFillModeRemoved</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4"><a href="#3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4" class="headerlink" title="3.4 层级关系时间"></a>3.4 层级关系时间</h2><p>对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。</p>
<h2 id="3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4"><a href="#3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4" class="headerlink" title="3.5 全局时间和本地时间"></a>3.5 全局时间和本地时间</h2><p> CoreAnimation有一个<em>全局时间</em>的概念，也就是所谓的<em>马赫时间</em>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTimeInterval</span> time = <span class="built_in">CACurrentMediaTime</span>();</span><br></pre></td></tr></table></figure>
<p> 这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的<code>CAAnimations</code>（基于马赫时间）同样也会暂停。</p>
<h2 id="3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB"><a href="#3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB" class="headerlink" title="3.6 暂停，倒回和快进"></a>3.6 暂停，倒回和快进</h2><p>给图层添加一个<code>CAAnimation</code>实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。</p>
<h2 id="3-7__u624B_u52A8_u52A8_u753B"><a href="#3-7__u624B_u52A8_u52A8_u753B" class="headerlink" title="3.7 手动动画"></a>3.7 手动动画</h2><p><code>timeOffset</code>一个很有用的功能在于它可以让你手动控制动画进程，通过设置<code>speed</code>为0，可以禁用动画的自动播放，然后来使用<code>timeOffset</code>来来回显示动画序列。这可以使得运用手势来手动控制动画变得很简单。</p>
<h1 id="u56DB_u3001_u7F13_u51B2"><a href="#u56DB_u3001_u7F13_u51B2" class="headerlink" title="四、缓冲"></a>四、缓冲</h1><h2 id="4-1__u52A8_u753B_u901F_u5EA6"><a href="#4-1__u52A8_u753B_u901F_u5EA6" class="headerlink" title="4.1 动画速度"></a>4.1 动画速度</h2><p>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">velocity</span> = change / <span class="built_in">time</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2_CAMediaTimingFunction"><a href="#4-2_CAMediaTimingFunction" class="headerlink" title="4.2 CAMediaTimingFunction"></a>4.2 <code>CAMediaTimingFunction</code></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAMediaTimingFunctionLinear</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseIn</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseOut</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span></span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionDefault</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2"><a href="#4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2" class="headerlink" title="4.3 UIView的动画缓冲"></a>4.3 <code>UIView</code>的动画缓冲</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseIn</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveLinear</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B"><a href="#4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="4.4 缓冲和关键帧动画"></a>4.4 缓冲和关键帧动画</h2><p> <code>CAKeyframeAnimation</code>有一个<code>NSArray</code>类型的<code>timingFunctions</code>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于<code>keyframes</code>数组的元素个数<em>减一</em>，因为它是描述每一帧之间动画速度的函数。</p>
<p><code>CAKeyframeAnimation</code>可以用来避开<code>CAMediaTimingFunction</code>的限制，创建完全自定义的缓冲函数。</p>
<h1 id="u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B"><a href="#u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B" class="headerlink" title="五、基于定时器的动画"></a>五、基于定时器的动画</h1><h2 id="5-1__u5B9A_u65F6_u5E27"><a href="#5-1__u5B9A_u65F6_u5E27" class="headerlink" title="5.1 定时帧"></a>5.1 定时帧</h2><p>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p><code>CAAnimation</code>最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<h2 id="5-2_NSTimer"><a href="#5-2_NSTimer" class="headerlink" title="5.2 NSTimer"></a>5.2 <code>NSTimer</code></h2><p> iOS上的每个线程都管理了一个<code>NSRunloop</code>，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘</li>
</ul>
<p>当你设置一个<code>NSTimer</code>，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</p>
<p>我们可以通过一些途径来优化：</p>
<ul>
<li>我们可以用<code>CADisplayLink</code>让更新频率严格控制在每次屏幕刷新之后。</li>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的<code>run loop</code>模式，这样就不会被别的事件干扰。</li>
</ul>
<h2 id="5-3_CADisplayLink"><a href="#5-3_CADisplayLink" class="headerlink" title="5.3 CADisplayLink"></a>5.3 <code>CADisplayLink</code></h2><p> <code>CADisplayLink</code>是CoreAnimation提供的另一个类似于<code>NSTimer</code>的类，它总是在屏幕完成一次更新之前启动。</p>
<p>当使用<code>NSTimer</code>的时候，一旦有机会计时器就会开启，但是<code>CADisplayLink</code>却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>