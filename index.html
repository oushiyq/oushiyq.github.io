<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Daniel Young's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daniel Young's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Core-Animation/" style="font-size: 10px;">Core Animation</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/23/iOS-Core-Animation-Advanced-Techniques阅读笔记（三）/" class="article-date">
  	<time datetime="2018-07-23T13:04:40.000Z" itemprop="datePublished">2018-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/iOS-Core-Animation-Advanced-Techniques阅读笔记（三）/">iOS Core Animation Advanced Techniques阅读笔记（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u6027_u80FD_u8C03_u4F18"><a href="#u4E00_u3001_u6027_u80FD_u8C03_u4F18" class="headerlink" title="一、性能调优"></a>一、性能调优</h1><h2 id="1-1_CPU_VS_GPU"><a href="#1-1_CPU_VS_GPU" class="headerlink" title="1.1 CPU VS GPU"></a>1.1 CPU VS GPU</h2><p>GPU使用图像对高度并行浮点运算做了优化。GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）</p>
<h3 id="1-1-1__u52A8_u753B_u7684_u821E_u53F0"><a href="#1-1-1__u52A8_u753B_u7684_u821E_u53F0" class="headerlink" title="1.1.1 动画的舞台"></a>1.1.1 动画的舞台</h3><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的<em>渲染服务</em>（<strong>render server</strong>）。</p>
<p>当运行一段动画时候，这个过程会被四个分离的阶段被打破：</p>
<ul>
<li><strong>布局</strong> - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。（<strong>开发者控制</strong>）</li>
<li><strong>显示</strong> - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>方法的调用路径。（<strong>开发者控制</strong>）</li>
<li><strong>准备</strong> - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li>
<li><strong>提交</strong> - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li>
</ul>
<p>一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<strong>渲染树</strong>的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p>
<ul>
<li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li>
<li>在屏幕上渲染可见的三角形（<strong>GPU处理</strong>）</li>
</ul>
<h3 id="1-1-2_GPU_u76F8_u5173_u7684_u64CD_u4F5C"><a href="#1-1-2_GPU_u76F8_u5173_u7684_u64CD_u4F5C" class="headerlink" title="1.1.2 GPU相关的操作"></a>1.1.2 GPU相关的操作</h3><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。</p>
<p>宽泛的说，大多数<code>CALayer</code>的属性都是用GPU来绘制。</p>
<p>降低（基于GPU）图层绘制的操作：</p>
<ol>
<li><strong>太多的几何结构</strong> - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。在Core Animation中几何结构并不是GPU的瓶颈所在，但由于图层在显示之前通过IPC发送到渲染服务器的时候，太多的图层就会引起CPU的瓶颈。</li>
<li><strong>重绘</strong> - 主要由重叠的半透明图层引起。GPU的<em>填充比率</em>（用颜色填充像素的比率）是有限的，所以需要避免<em>重绘</em>（每一帧用相同的像素填充多次）的发生。</li>
<li><strong>离屏绘制</strong> - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。</li>
<li><strong>过大的图片</strong> - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</li>
</ol>
<h3 id="1-1-3_CPU_u76F8_u5173_u7684_u64CD_u4F5C"><a href="#1-1-3_CPU_u76F8_u5173_u7684_u64CD_u4F5C" class="headerlink" title="1.1.3 CPU相关的操作"></a>1.1.3 CPU相关的操作</h3><p>在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p>
<p> 以下CPU的操作都会延迟动画的开始时间：</p>
<ul>
<li><strong>布局计算</strong> - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。</li>
<li><strong>视图惰性加载</strong> - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。</li>
<li><strong>Core Graphics绘制</strong> - 如果对视图实现了<code>-drawRect:</code>方法，或者<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢。</li>
<li><strong>解压图片</strong> - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用<code>UIImageView</code>）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li>
</ul>
<h2 id="1-2_Instruments"><a href="#1-2_Instruments" class="headerlink" title="1.2 Instruments"></a>1.2 Instruments</h2><ul>
<li><strong>时间分析器</strong> - 用来测量被方法/函数打断的CPU使用情况。</li>
<li><strong>Core Animation</strong> - 用来调试各种Core Animation性能问题。</li>
<li><strong>OpenGL ES驱动</strong> - 用来调试GPU性能问题。这个工具在编写Open GL代码的时候很有用，但有时也用来处理Core Animation的工作。</li>
</ul>
<p>Core Animation工具也提供了一系列复选框选项来帮助调试渲染瓶颈：</p>
<ul>
<li><strong>Color Blended Layers</strong> - 这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮（也就是多个半透明图层的叠加）。由于重绘的原因，混合对GPU性能会有影响，同时也是滑动或者动画帧率下降的罪魁祸首之一。</li>
<li><strong>ColorHitsGreenandMissesRed</strong> - 当使用<code>shouldRasterized</code>属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存再生的时候这个选项就用红色对栅格化图层进行了高亮。如果缓存频繁再生的话，就意味着栅格化可能会有负面的性能影响了。</li>
<li><strong>Color Copied Images</strong> - 有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</li>
<li><strong>Color Immediately</strong> - 通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>
<li><strong>Color Misaligned Images</strong> - 这里会高亮那些被缩放或者拉伸以及没有正确对齐到像素边界的图片（也就是非整型坐标）。这些中的大多数通常都会导致图片的不正常缩放，如果把一张大图当缩略图显示，或者不正确地模糊图像，那么这个选项将会帮你识别出问题所在。</li>
<li><strong>Color Offscreen-Rendered Yellow</strong> - 这里会把那些需要离屏渲染的图层高亮成黄色。这些图层很可能需要用<code>shadowPath</code>或者<code>shouldRasterize</code>来优化。</li>
<li><strong>Color OpenGL Fast Path Blue</strong> - 这个选项会对任何直接使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animation的API，那么不会有任何效果。如果使用<code>GLKView</code>或者<code>CAEAGLLayer</code>，那如果不显示蓝色块的话就意味着你正在强制CPU渲染额外的纹理，而不是绘制到屏幕。</li>
<li><strong>Flash Updated Regions</strong> - 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。</li>
</ul>
<h1 id="u4E8C_u3001_u9AD8_u6548_u7ED8_u56FE"><a href="#u4E8C_u3001_u9AD8_u6548_u7ED8_u56FE" class="headerlink" title="二、高效绘图"></a>二、高效绘图</h1><h2 id="2-1__u8F6F_u4EF6_u7ED8_u56FE"><a href="#2-1__u8F6F_u4EF6_u7ED8_u56FE" class="headerlink" title="2.1 软件绘图"></a>2.1 软件绘图</h2><p>在iOS中，软件绘图通常是由Core Graphics框架完成来完成。但是，在一些必要的情况下，相比Core Animation和OpenGL，Core Graphics要慢了不少。</p>
<p>软件绘图不仅效率低，还会消耗可观的内存。<code>CALayer</code>只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。</p>
<p>但是一旦你实现了<code>CALayerDelegate</code>协议中的<code>-drawLayer:inContext:</code>方法或者<code>UIView</code>中的<code>-drawRect:</code>方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽<em>图层高</em>4字节，宽高的单位均为像素。</p>
<p>提高绘制性能的秘诀就在于尽量避免去绘制。</p>
<h2 id="2-2__u77E2_u91CF_u56FE_u5F62"><a href="#2-2__u77E2_u91CF_u56FE_u5F62" class="headerlink" title="2.2 矢量图形"></a>2.2 矢量图形</h2><p>我们用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能轻易地绘制出矢量图形。矢量绘图包含一下这些：</p>
<ul>
<li>任意多边形（不仅仅是一个矩形）</li>
<li>斜线或曲线</li>
<li>文本</li>
<li>渐变</li>
</ul>
<p>Core Animation为这些图形类型的绘制提供了专门的类，并给他们提供硬件支持。</p>
<ul>
<li><p><code>CAShapeLayer</code>可以绘制多边形，直线和曲线。</p>
</li>
<li><p><code>CATextLayer</code>可以绘制文本。</p>
</li>
<li><p><code>CAGradientLayer</code>用来绘制渐变。这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。</p>
</li>
</ul>
<h2 id="2-3__u810F_u77E9_u5F62"><a href="#2-3__u810F_u77E9_u5F62" class="headerlink" title="2.3 脏矩形"></a>2.3 脏矩形</h2><p>为了减少不必要的绘制，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而这个位置就是『脏矩形』。</p>
<p>当你检测到指定视图或图层的指定部分需要被重绘，你直接调用<code>-setNeedsDisplayInRect:</code>来标记它，然后将影响到的矩形作为参数传入。这样就会在一次视图刷新时调用视图的<code>-drawRect:</code>（或图层代理的<code>-drawLayer:inContext:</code>方法）。</p>
<p>传入<code>-drawLayer:inContext:</code>的<code>CGContext</code>参数会自动被裁切以适应对应的矩形。为了确定矩形的尺寸大小，你可以用<code>CGContextGetClipBoundingBox()</code>方法来从上下文获得大小。调用<code>-drawRect()</code>会更简单，因为<code>CGRect</code>会作为参数直接传入。</p>
<h2 id="2-4__u5F02_u6B65_u7ED8_u5236"><a href="#2-4__u5F02_u6B65_u7ED8_u5236" class="headerlink" title="2.4 异步绘制"></a>2.4 异步绘制</h2><p> <code>CATiledLayer</code>除了将图层再次分割成独立更新的小块（类似于脏矩形自动更新的概念），<code>CATiledLayer</code>还有一个特性：在多个线程中为每个小块同时调用<code>-drawLayer:inContext:</code>方法。</p>
<p><code>drawsAsynchronously</code>属性对传入<code>-drawLayer:inContext:</code>的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。</p>
<p> <code>drawsAsynchronously</code>与<code>CATiledLayer</code>使用的异步绘制并不相同。它自己的<code>-drawLayer:inContext:</code>方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。</p>
<h1 id="u4E09_u3001_u56FE_u50CFIO"><a href="#u4E09_u3001_u56FE_u50CFIO" class="headerlink" title="三、图像IO"></a>三、图像IO</h1><h2 id="3-1__u52A0_u8F7D_u548C_u6F5C_u4F0F"><a href="#3-1__u52A0_u8F7D_u548C_u6F5C_u4F0F" class="headerlink" title="3.1 加载和潜伏"></a>3.1 加载和潜伏</h2><p> 绘图实际消耗的时间通常并不是影响性能的因素。图片消耗很大一部分内存，而且不太可能把需要显示的图片都保留在内存中，所以需要在应用运行的时候周期性地加载和卸载图片。</p>
<h3 id="3-1-1__u7EBF_u7A0B_u52A0_u8F7D"><a href="#3-1-1__u7EBF_u7A0B_u52A0_u8F7D" class="headerlink" title="3.1.1 线程加载"></a>3.1.1 线程加载</h3><p>滑动动画会在主线程的run loop中更新，它们是在渲染服务进程中运行的，并因此更容易比CAAnimation遭受CPU相关的性能问题。</p>
<h3 id="3-1-2_GCD_u548CNSOperationQueue"><a href="#3-1-2_GCD_u548CNSOperationQueue" class="headerlink" title="3.1.2 GCD和NSOperationQueue"></a>3.1.2 GCD和<code>NSOperationQueue</code></h3><p>GCD（Grand Central Dispatch）和<code>NSOperationQueue</code>很类似，都给我们提供了队列闭包块来在线程中按一定顺序来执行。<code>NSOperationQueue</code>有一个Objecive-C接口（而不是使用GCD的全局C函数），同样在操作优先级和依赖关系上提供了很好的粒度控制，但是需要更多地设置代码。</p>
<h3 id="3-1-3__u5EF6_u8FDF_u89E3_u538B"><a href="#3-1-3__u5EF6_u8FDF_u89E3_u538B" class="headerlink" title="3.1.3 延迟解压"></a>3.1.3 延迟解压</h3><p> 用于加载的CPU时间相对于解码来说根据图片格式而不同。对于PNG图片来说，加载会比JPEG更长，因为文件可能更大，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为JPEG解压算法比基于zip的PNG算法更加复杂。</p>
<p>当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。</p>
<p>有两种方式可以为强制解压提前渲染图片：</p>
<ol>
<li>将图片的一个像素绘制成一个像素大小的<code>CGContext</code>。这样仍然会解压整张图片，但是绘制本身并没有消耗任何时间。这样的好处在于加载的图片并不会在特定的设备上为绘制做优化，所以可以在任何时间点绘制出来。同样iOS也就可以丢弃解压后的图片来节省内存了。</li>
<li>张图片绘制到<code>CGContext</code>中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素那样需要更加复杂的计算，但是因此产生的图片将会为绘制做优化，而且由于原始压缩图片被抛弃了，iOS就不能够随时丢弃任何解压后的图片来节省内存了。</li>
</ol>
<h3 id="3-1-4_CATiledLayer"><a href="#3-1-4_CATiledLayer" class="headerlink" title="3.1.4  CATiledLayer"></a>3.1.4  <code>CATiledLayer</code></h3><p> <code>CATiledLayer</code>可以用来异步加载和显示大型图片，而不阻塞用户输入。</p>
<h3 id="3-1-5__u5206_u8FA8_u7387_u4EA4_u6362"><a href="#3-1-5__u5206_u8FA8_u7387_u4EA4_u6362" class="headerlink" title="3.1.5 分辨率交换"></a>3.1.5 分辨率交换</h3><p> 如果需要快速加载和显示移动大图，简单的办法就是欺骗人眼，在移动传送器的时候显示一个小图（或者低分辨率），然后当停止的时候再换成大图。</p>
<h2 id="3-2__u7F13_u5B58"><a href="#3-2__u7F13_u5B58" class="headerlink" title="3.2 缓存"></a>3.2 缓存</h2><p>缓存其实很简单：就是将昂贵计算后的结果（或者是从闪存或者网络加载的文件）存储到内存中，以便后续使用，这样访问起来很快。问题在于缓存本质上是一个权衡过程 - 为了提升性能而消耗了内存，但是由于内存是一个非常宝贵的资源，所以不能把所有东西都做缓存。</p>
<h3 id="3-2-1_+imageNamed_3A_u65B9_u6CD5"><a href="#3-2-1_+imageNamed_3A_u65B9_u6CD5" class="headerlink" title="3.2.1 +imageNamed:方法"></a>3.2.1 <code>+imageNamed:</code>方法</h3><p><code>[UIImage imageNamed:]</code>加载图片有个好处在于可以立刻解压图片而不用等到绘制的时候。但是<code>[UIImage imageNamed:]</code>方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。</p>
<ul>
<li><code>[UIImage imageNamed:]</code>方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以<code>[UIImage imageNamed:]</code>就没法用了。</li>
<li><code>[UIImage imageNamed:]</code>缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。</li>
<li><code>[UIImage imageNamed:]</code>缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。</li>
</ul>
<h3 id="3-2-2__u81EA_u5B9A_u4E49_u7F13_u5B58"><a href="#3-2-2__u81EA_u5B9A_u4E49_u7F13_u5B58" class="headerlink" title="3.2.2 自定义缓存"></a>3.2.2 自定义缓存</h3><ul>
<li>选择一个合适的缓存键 - 缓存键用来做图片的唯一标识。如果实时创建图片，通常不太好生成一个字符串来区分别的图片。在我们的图片传送带例子中就很简单，我们可以用图片的文件名或者表格索引。</li>
<li>提前缓存 - 如果生成和加载数据的代价很大，你可能想当第一次需要用到的时候再去加载和缓存。提前加载的逻辑是应用内在就有的，但是在我们的例子中，这也非常好实现，因为对于一个给定的位置和滚动方向，我们就可以精确地判断出哪一张图片将会出现。</li>
<li>缓存失效 - 如果图片文件发生了变化，怎样才能通知到缓存更新呢？这是个非常困难的问题（就像菲尔 卡尔顿提到的），但是幸运的是当从程序资源加载静态图片的时候并不需要考虑这些。对用户提供的图片来说（可能会被修改或者覆盖），一个比较好的方式就是当图片缓存的时候打上一个时间戳以便当文件更新的时候作比较。</li>
<li>缓存回收 - 当内存不够的时候，如何判断哪些缓存需要清空呢？这就需要到你写一个合适的算法了。幸运的是，对缓存回收的问题，苹果提供了一个叫做<code>NSCache</code>通用的解决方案</li>
</ul>
<h3 id="3-2-3_NSCache"><a href="#3-2-3_NSCache" class="headerlink" title="3.2.3 NSCache"></a>3.2.3 NSCache</h3><p><code>NSCache</code>和<code>NSDictionary</code>类似。你可以通过<code>-setObject:forKey:</code>和<code>-object:forKey:</code>方法分别来插入，检索。和字典不同的是，<code>NSCache</code>在系统低内存的时候自动丢弃存储的对象。</p>
<h2 id="3-3__u6587_u4EF6_u683C_u5F0F"><a href="#3-3__u6587_u4EF6_u683C_u5F0F" class="headerlink" title="3.3 文件格式"></a>3.3 文件格式</h2><p> PNG和JPEG压缩算法作用于两种不同的图片类型：JPEG对于噪点大的图片效果很好；但是PNG更适合于扁平颜色，锋利的线条或者一些渐变色的图片。</p>
<h1 id="u56DB_u3001__u56FE_u5C42_u6027_u80FD"><a href="#u56DB_u3001__u56FE_u5C42_u6027_u80FD" class="headerlink" title="四、 图层性能"></a>四、 图层性能</h1><h2 id="4-1__u9690_u5F0F_u7ED8_u5236"><a href="#4-1__u9690_u5F0F_u7ED8_u5236" class="headerlink" title="4.1 隐式绘制"></a>4.1 隐式绘制</h2><p> 寄宿图可以通过Core Graphics直接绘制，也可以直接载入一个图片文件并赋值给<code>contents</code>属性，或事先绘制一个屏幕之外的<code>CGContext</code>上下文。除了常见的显式创建寄宿图，你也可以通过以下三种方式创建隐式的：</p>
<ol>
<li>使用特性的图层属性</li>
<li>特定的视图</li>
<li>特定的图层子类</li>
</ol>
<h3 id="4-1-1__u6587_u672C"><a href="#4-1-1__u6587_u672C" class="headerlink" title="4.1.1 文本"></a>4.1.1 文本</h3><p><code>CATextLayer</code>和<code>UILabel</code>都是直接将文本绘制在图层的寄宿图中。尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文本就需要重绘。</p>
<h3 id="4-1-2__u5149_u6805_u5316"><a href="#4-1-2__u5149_u6805_u5316" class="headerlink" title="4.1.2 光栅化"></a>4.1.2 光栅化</h3><p>启用<code>shouldRasterize</code>属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的<code>contents</code>和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。</p>
<h2 id="4-2__u79BB_u5C4F_u6E32_u67D3"><a href="#4-2__u79BB_u5C4F_u6E32_u67D3" class="headerlink" title="4.2 离屏渲染"></a>4.2 离屏渲染</h2><p> 当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。图层的以下属性将会触发屏幕外绘制：</p>
<ul>
<li>圆角（当和<code>maskToBounds</code>一起使用时）</li>
<li>图层蒙板</li>
<li>阴影</li>
</ul>
<h3 id="4-2-1_CAShapeLayer"><a href="#4-2-1_CAShapeLayer" class="headerlink" title="4.2.1 CAShapeLayer"></a>4.2.1 CAShapeLayer</h3><p><code>cornerRadius</code>和<code>maskToBounds</code>独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候你想显示圆角并沿着图层裁切子图层的时候，你可能会发现你并不需要沿着圆角裁切，这个情况下用<code>CAShapeLayer</code>就可以避免这个问题了。</p>
<h3 id="4-2-2__u53EF_u4F38_u7F29_u56FE_u7247"><a href="#4-2-2__u53EF_u4F38_u7F29_u56FE_u7247" class="headerlink" title="4.2.2 可伸缩图片"></a>4.2.2 可伸缩图片</h3><p>使用可伸缩图片的优势在于它可以绘制成任意边框效果而不需要额外的性能消耗。</p>
<h3 id="4-2-3_shadowPath"><a href="#4-2-3_shadowPath" class="headerlink" title="4.2.3 shadowPath"></a>4.2.3 shadowPath</h3><p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），创建出一个对应形状的阴影路径就比较容易，而且Core Animation绘制这个阴影也相当简单，避免了屏幕外的图层部分的预排版需求。这对性能来说很有帮助。</p>
<h2 id="4-3__u6DF7_u5408_u548C_u8FC7_u5EA6_u7ED8_u5236"><a href="#4-3__u6DF7_u5408_u548C_u8FC7_u5EA6_u7ED8_u5236" class="headerlink" title="4.3 混合和过度绘制"></a>4.3 混合和过度绘制</h2><p>GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。</p>
<p>GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当可观的。</p>
<ul>
<li>给视图的<code>backgroundColor</code>属性设置一个固定的，不透明的颜色</li>
<li>设置<code>opaque</code>属性为YES</li>
</ul>
<p>如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。</p>
<p>如果是文本的话，一个白色背景的<code>UILabel</code>（或者其他颜色）会比透明背景要更高效。</p>
<p>最后，明智地使用<code>shouldRasterize</code>属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</p>
<p><code>shouldRasterize</code>，它自动地处理缓存和缓存验证</p>
<h2 id="4-4__u51CF_u5C11_u56FE_u5C42_u6570_u91CF"><a href="#4-4__u51CF_u5C11_u56FE_u5C42_u6570_u91CF" class="headerlink" title="4.4 减少图层数量"></a>4.4 减少图层数量</h2><p> 初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成OpenGL几何图形，这些是一个图层的大致资源开销。事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。</p>
<p>处理巨大数量的相似视图或图层时还有一个技巧就是回收他们。</p>
<p>没有与图层树相关联的图层不会被送到渲染引擎，也没有性能问题（在他们被创建和配置之后）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/" class="article-date">
  	<time datetime="2018-07-22T15:21:45.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/iOS-Core-Animation-Advanced-Techniques阅读笔记（二）/">iOS Core Animation Advanced Techniques阅读笔记（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u9690_u5F0F_u52A8_u753B"><a href="#u4E00_u3001_u9690_u5F0F_u52A8_u753B" class="headerlink" title="一、隐式动画"></a>一、隐式动画</h1><h2 id="1-1__u4E8B_u52A1"><a href="#1-1__u4E8B_u52A1" class="headerlink" title="1.1 事务"></a>1.1 事务</h2><p>隐式动画:我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画</p>
<p>动画执行的时间取决于当前<em>事务</em>的设置，动画类型取决于<em>图层行为</em>。</p>
<p>Core Animation在每个<em>run loop</em>周期中自动开始一次新的事务，即使你不显式地使用<code>[CATransaction begin]</code>开始一次事务，在一个特定run loop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。</p>
<h2 id="1-2__u5B8C_u6210_u5757"><a href="#1-2__u5B8C_u6210_u5757" class="headerlink" title="1.2 完成块"></a>1.2 完成块</h2><p>基于<code>UIView</code>的block的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。</p>
<h2 id="1-3__u56FE_u5C42_u884C_u4E3A"><a href="#1-3__u56FE_u5C42_u884C_u4E3A" class="headerlink" title="1.3 图层行为"></a>1.3 图层行为</h2><ul>
<li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li>
<li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li>
</ul>
<h2 id="1-4__u5448_u73B0_u4E0E_u6A21_u578B"><a href="#1-4__u5448_u73B0_u4E0E_u6A21_u578B" class="headerlink" title="1.4 呈现与模型"></a>1.4 呈现与模型</h2><p>设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p>
<p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p>
<p>每个图层属性的显示值都被存储在一个叫做 <strong>呈现图层</strong> 的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p>
<p><strong>呈现树 </strong>通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p>
<p> 两种情况下呈现图层会变得很有用，一个是<strong>同步动画</strong>，一个是处理<strong>用户交互</strong>。</p>
<ul>
<li>如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<h1 id="u4E8C_u3001_u663E_u5F0F_u52A8_u753B"><a href="#u4E8C_u3001_u663E_u5F0F_u52A8_u753B" class="headerlink" title="二、显式动画"></a>二、显式动画</h1><h2 id="2-1__u5C5E_u6027_u52A8_u753B"><a href="#2-1__u5C5E_u6027_u52A8_u753B" class="headerlink" title="2.1 属性动画"></a>2.1 属性动画</h2><p>属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：<em>基础</em>和<em>关键帧</em>。</p>
<p>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是<code>CABasicAnimation</code>最主要的功能。</p>
<p>像所有的<code>NSObject</code>子类一样，<code>CAAnimation</code>实现了KVC（键-值-编码）协议，于是你可以用<code>-setValue:forKey:</code>和<code>-valueForKey:</code>方法来存取属性。但是<code>CAAnimation</code>有一个与众不同的特性：它更像一个<code>NSDictionary</code>，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<h2 id="2-2__u5173_u952E_u5E27_u52A8_u753B"><a href="#2-2__u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="2.2 关键帧动画"></a>2.2 关键帧动画</h2><p><code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code>那样把<code>fromValue</code>设为<code>nil</code>）。</p>
<h2 id="2-3__u865A_u62DF_u5C5E_u6027"><a href="#2-3__u865A_u62DF_u5C5E_u6027" class="headerlink" title="2.3 虚拟属性"></a>2.3 虚拟属性</h2><p><code>transform.rotation</code>而不是<code>transform</code>做动画的好处如下：</p>
<ul>
<li>我们可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置<code>byValue</code>而不是<code>toValue</code>）。</li>
<li>可以不用创建<code>CATransform3D</code>，而是使用一个简单的数值来指定角度。</li>
<li>不会和<code>transform.position</code>或者<code>transform.scale</code>冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<p><code>transform.rotation</code>属性有一个奇怪的问题是它其实<em>并不存在</em>。这是因为<code>CATransform3D</code>并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，<code>transform.rotation</code>实际上是一个<code>CALayer</code>用于处理动画变换的<em>虚拟</em>属性。</p>
<h2 id="2-4__u52A8_u753B_u7EC4"><a href="#2-4__u52A8_u753B_u7EC4" class="headerlink" title="2.4 动画组"></a>2.4 动画组</h2><p><code>CABasicAnimation</code>和<code>CAKeyframeAnimation</code>仅仅作用于单独的属性，而<code>CAAnimationGroup</code>可以把这些动画组合在一起。</p>
<h2 id="2-5__u8FC7_u6E21"><a href="#2-5__u8FC7_u6E21" class="headerlink" title="2.5 过渡"></a>2.5 过渡</h2><p><code>CATransition</code>，同样是另一个<code>CAAnimation</code>的子类，和别的子类不同，<code>CATransition</code>有一个<code>type</code>和<code>subtype</code>来标识变换效果。<code>type</code>属性是一个<code>NSString</code>类型，可以被设置成如下类型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CATransitionFade</span> </span><br><span class="line">k<span class="built_in">CATransitionMoveIn</span> </span><br><span class="line">k<span class="built_in">CATransitionPush</span> </span><br><span class="line">k<span class="built_in">CATransitionReveal</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6__u9690_u5F0F_u8FC7_u6E21"><a href="#2-6__u9690_u5F0F_u8FC7_u6E21" class="headerlink" title="2.6 隐式过渡"></a>2.6 隐式过渡</h2><p><code>CATransision</code>可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。</p>
<h2 id="2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B"><a href="#2-7__u5BF9_u56FE_u5C42_u6811_u7684_u52A8_u753B" class="headerlink" title="2.7 对图层树的动画"></a>2.7 对图层树的动画</h2><p><code>CATransition</code>并不作用于指定的图层属性。</p>
<h2 id="2-8__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#2-8__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="2.8 自定义动画"></a>2.8 自定义动画</h2><p><code>UIView</code>过渡方法中<code>options</code>参数可以由如下常量指定：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlUp</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCurlDown</span></span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromTop</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionTransitionFlipFromBottom</span></span><br></pre></td></tr></table></figure>
<h2 id="2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B"><a href="#2-9__u5728_u52A8_u753B_u8FC7_u7A0B_u4E2D_u53D6_u6D88_u52A8_u753B" class="headerlink" title="2.9 在动画过程中取消动画"></a>2.9 在动画过程中取消动画</h2><p>动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<h1 id="u4E09_u3001_u56FE_u5C42_u65F6_u95F4"><a href="#u4E09_u3001_u56FE_u5C42_u65F6_u95F4" class="headerlink" title="三、图层时间"></a>三、图层时间</h1><h2 id="3-1_CAMediaTiming_u534F_u8BAE"><a href="#3-1_CAMediaTiming_u534F_u8BAE" class="headerlink" title="3.1 CAMediaTiming协议"></a>3.1 <code>CAMediaTiming</code>协议</h2><p><code>CAMediaTiming</code>协议定义了在一段动画内用来控制逝去时间的属性的集合，<code>CALayer</code>和<code>CAAnimation</code>都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>
<h2 id="3-2__u76F8_u5BF9_u65F6_u95F4"><a href="#3-2__u76F8_u5BF9_u65F6_u95F4" class="headerlink" title="3.2 相对时间"></a>3.2 相对时间</h2><p> 每次讨论到Core Animation，时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>
<h2 id="3-3_fillMode"><a href="#3-3_fillMode" class="headerlink" title="3.3 fillMode"></a>3.3 <code>fillMode</code></h2><p> <code>fillMode</code>是一个<code>NSString</code>类型，可以接受如下四种常量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAFillModeForwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBackwards</span></span><br><span class="line">k<span class="built_in">CAFillModeBoth</span></span><br><span class="line">k<span class="built_in">CAFillModeRemoved</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4"><a href="#3-4__u5C42_u7EA7_u5173_u7CFB_u65F6_u95F4" class="headerlink" title="3.4 层级关系时间"></a>3.4 层级关系时间</h2><p>对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。</p>
<h2 id="3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4"><a href="#3-5__u5168_u5C40_u65F6_u95F4_u548C_u672C_u5730_u65F6_u95F4" class="headerlink" title="3.5 全局时间和本地时间"></a>3.5 全局时间和本地时间</h2><p> CoreAnimation有一个<em>全局时间</em>的概念，也就是所谓的<em>马赫时间</em>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTimeInterval</span> time = <span class="built_in">CACurrentMediaTime</span>();</span><br></pre></td></tr></table></figure>
<p> 这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的<code>CAAnimations</code>（基于马赫时间）同样也会暂停。</p>
<h2 id="3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB"><a href="#3-6__u6682_u505C_uFF0C_u5012_u56DE_u548C_u5FEB_u8FDB" class="headerlink" title="3.6 暂停，倒回和快进"></a>3.6 暂停，倒回和快进</h2><p>给图层添加一个<code>CAAnimation</code>实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。</p>
<h2 id="3-7__u624B_u52A8_u52A8_u753B"><a href="#3-7__u624B_u52A8_u52A8_u753B" class="headerlink" title="3.7 手动动画"></a>3.7 手动动画</h2><p><code>timeOffset</code>一个很有用的功能在于它可以让你手动控制动画进程，通过设置<code>speed</code>为0，可以禁用动画的自动播放，然后来使用<code>timeOffset</code>来来回显示动画序列。这可以使得运用手势来手动控制动画变得很简单。</p>
<h1 id="u56DB_u3001_u7F13_u51B2"><a href="#u56DB_u3001_u7F13_u51B2" class="headerlink" title="四、缓冲"></a>四、缓冲</h1><h2 id="4-1__u52A8_u753B_u901F_u5EA6"><a href="#4-1__u52A8_u753B_u901F_u5EA6" class="headerlink" title="4.1 动画速度"></a>4.1 动画速度</h2><p>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">velocity</span> = change / <span class="built_in">time</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2_CAMediaTimingFunction"><a href="#4-2_CAMediaTimingFunction" class="headerlink" title="4.2 CAMediaTimingFunction"></a>4.2 <code>CAMediaTimingFunction</code></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k<span class="built_in">CAMediaTimingFunctionLinear</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseIn</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseOut</span> </span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span></span><br><span class="line">k<span class="built_in">CAMediaTimingFunctionDefault</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2"><a href="#4-3_UIView_u7684_u52A8_u753B_u7F13_u51B2" class="headerlink" title="4.3 UIView的动画缓冲"></a>4.3 <code>UIView</code>的动画缓冲</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseIn</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveEaseOut</span> </span><br><span class="line"><span class="built_in">UIViewAnimationOptionCurveLinear</span></span><br></pre></td></tr></table></figure>
<h2 id="4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B"><a href="#4-4__u7F13_u51B2_u548C_u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="4.4 缓冲和关键帧动画"></a>4.4 缓冲和关键帧动画</h2><p> <code>CAKeyframeAnimation</code>有一个<code>NSArray</code>类型的<code>timingFunctions</code>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于<code>keyframes</code>数组的元素个数<em>减一</em>，因为它是描述每一帧之间动画速度的函数。</p>
<p><code>CAKeyframeAnimation</code>可以用来避开<code>CAMediaTimingFunction</code>的限制，创建完全自定义的缓冲函数。</p>
<h1 id="u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B"><a href="#u4E94_u3001_u57FA_u4E8E_u5B9A_u65F6_u5668_u7684_u52A8_u753B" class="headerlink" title="五、基于定时器的动画"></a>五、基于定时器的动画</h1><h2 id="5-1__u5B9A_u65F6_u5E27"><a href="#5-1__u5B9A_u65F6_u5E27" class="headerlink" title="5.1 定时帧"></a>5.1 定时帧</h2><p>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p><code>CAAnimation</code>最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<h2 id="5-2_NSTimer"><a href="#5-2_NSTimer" class="headerlink" title="5.2 NSTimer"></a>5.2 <code>NSTimer</code></h2><p> iOS上的每个线程都管理了一个<code>NSRunloop</code>，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘</li>
</ul>
<p>当你设置一个<code>NSTimer</code>，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</p>
<p>我们可以通过一些途径来优化：</p>
<ul>
<li>我们可以用<code>CADisplayLink</code>让更新频率严格控制在每次屏幕刷新之后。</li>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的<code>run loop</code>模式，这样就不会被别的事件干扰。</li>
</ul>
<h2 id="5-3_CADisplayLink"><a href="#5-3_CADisplayLink" class="headerlink" title="5.3 CADisplayLink"></a>5.3 <code>CADisplayLink</code></h2><p> <code>CADisplayLink</code>是CoreAnimation提供的另一个类似于<code>NSTimer</code>的类，它总是在屏幕完成一次更新之前启动。</p>
<p>当使用<code>NSTimer</code>的时候，一旦有机会计时器就会开启，但是<code>CADisplayLink</code>却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/20/iOS-Core-Animation-Advanced-Techniques阅读笔记（一）/" class="article-date">
  	<time datetime="2018-07-20T04:15:51.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/iOS-Core-Animation-Advanced-Techniques阅读笔记（一）/">iOS Core Animation Advanced Techniques阅读笔记（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u56FE_u5C42_u6811"><a href="#u4E00_u3001_u56FE_u5C42_u6811" class="headerlink" title="一、图层树"></a>一、图层树</h1><p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。</p>
<h2 id="1-1__u56FE_u5C42_u4E0E_u89C6_u56FE"><a href="#1-1__u56FE_u5C42_u4E0E_u89C6_u56FE" class="headerlink" title="1.1 图层与视图"></a>1.1 图层与视图</h2><p>在iOS当中，所有的视图都从一个叫做<code>UIVIew</code>的基类派生而来，<code>UIView</code>可以处理触摸事件，可以支持基于<em>Core Graphics</em>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<h2 id="1-2_CALayer"><a href="#1-2_CALayer" class="headerlink" title="1.2 CALayer"></a>1.2 CALayer</h2><p><code>CALayer</code>和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。<code>CALayer</code>不知晓具体的响应链，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<h2 id="1-3__u5E73_u884C_u7684_u5C42_u7EA7_u5173_u7CFB"><a href="#1-3__u5E73_u884C_u7684_u5C42_u7EA7_u5173_u7CFB" class="headerlink" title="1.3 平行的层级关系"></a>1.3 平行的层级关系</h2><p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。</p>
<p><code>CALayer</code>才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>这个做的原因在于要做职责分离。</p>
<p>在<strong>视图层级</strong>和<strong>图层树</strong>之外，还存在<strong>呈现树</strong>和<strong>渲染树</strong>。</p>
<h2 id="1-4__u56FE_u5C42_u7684_u80FD_u529B"><a href="#1-4__u56FE_u5C42_u7684_u80FD_u529B" class="headerlink" title="1.4 图层的能力"></a>1.4 图层的能力</h2><ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h2 id="1-5__u4F7F_u7528_u56FE_u5C42"><a href="#1-5__u4F7F_u7528_u56FE_u5C42" class="headerlink" title="1.5 使用图层"></a>1.5 使用图层</h2><p>一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层。</p>
<p>使用图层关联的视图而不是<code>CALayer</code>的好处在于，你能在使用所有<code>CALayer</code>底层特性的同时，也可以使用<code>UIView</code>的高级API（比如自动排版，布局和事件处理）。</p>
<h1 id="u4E8C_u3001_u5BC4_u5BBF_u56FE_uFF08_u56FE_u5C42_u5305_u542B_u7684_u56FE_uFF09"><a href="#u4E8C_u3001_u5BC4_u5BBF_u56FE_uFF08_u56FE_u5C42_u5305_u542B_u7684_u56FE_uFF09" class="headerlink" title="二、寄宿图（图层包含的图）"></a>二、寄宿图（图层包含的图）</h1><h2 id="2-1_contents_u5C5E_u6027"><a href="#2-1_contents_u5C5E_u6027" class="headerlink" title="2.1 contents属性"></a>2.1 contents属性</h2><p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。</p>
<p><code>layer.contents = (__bridge id)image.CGImage;</code></p>
<p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。</p>
<h2 id="2-2_contentGravity"><a href="#2-2_contentGravity" class="headerlink" title="2.2 contentGravity"></a>2.2 contentGravity</h2><p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<h2 id="2-3_contentsScale"><a href="#2-3_contentsScale" class="headerlink" title="2.3 contentsScale"></a>2.3 contentsScale</h2><p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p> CGImage没有拉伸的概念。当我们使用UIImage类去读取图片的时候，它读取了Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。</p>
<h2 id="2-4_maskToBounds"><a href="#2-4_maskToBounds" class="headerlink" title="2.4 maskToBounds"></a>2.4 maskToBounds</h2><p>CALayer与<code>clipsToBounds</code>对应的属性为<code>masksToBounds</code></p>
<h2 id="2-5_contentsRect"><a href="#2-5_contentsRect" class="headerlink" title="2.5 contentsRect"></a>2.5 contentsRect</h2><p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。</p>
<p><code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值。默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。</p>
<p>iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准清晰度的设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是它们在处理图片时仍然是相关的。UIImage可以识别屏幕分辨，并以点为单位指定其大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，它们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<h2 id="2-6_contentsCenter"><a href="#2-6_contentsCenter" class="headerlink" title="2.6 contentsCenter"></a>2.6 contentsCenter</h2><p><code>contentsCenter</code>其实是一个CGRect，它定义了图层中的可拉伸区域和一个固定的边框。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<h2 id="2-7_Custome_Drawing"><a href="#2-7_Custome_Drawing" class="headerlink" title="2.7 Custome Drawing"></a>2.7 Custome Drawing</h2><p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p>如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>需要注意的是：</p>
<ul>
<li>不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<h1 id="u4E09_u3001_u56FE_u50CF_u51E0_u4F55_u5B66"><a href="#u4E09_u3001_u56FE_u50CF_u51E0_u4F55_u5B66" class="headerlink" title="三、图像几何学"></a>三、图像几何学</h1><h2 id="3-1__u5E03_u5C40"><a href="#3-1__u5E03_u5C40" class="headerlink" title="3.1 布局"></a>3.1 布局</h2><p>UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值。</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（在旋转中，layer和view俩者bounds保持不变，frame改变）</p>
<h2 id="3-2__u951A_u70B9"><a href="#3-2__u951A_u70B9" class="headerlink" title="3.2 锚点"></a>3.2 锚点</h2><p>图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动，而不是居中了。当CALayer的anchorPoint改变时，其frame随之改变，而position保存不变。</p>
<h2 id="3-3__u7FFB_u8F6C_u7684_u51E0_u4F55_u7ED3_u6784"><a href="#3-3__u7FFB_u8F6C_u7684_u51E0_u4F55_u7ED3_u6784" class="headerlink" title="3.3 翻转的几何结构"></a>3.3 翻转的几何结构</h2><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部。</p>
<h2 id="3-4_Z_u5750_u6807_u8F74"><a href="#3-4_Z_u5750_u6807_u8F74" class="headerlink" title="3.4 Z坐标轴"></a>3.4 Z坐标轴</h2><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p><code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<strong>画家的算法</strong></p>
<h2 id="3-5_Hit_Testing"><a href="#3-5_Hit_Testing" class="headerlink" title="3.5 Hit Testing"></a>3.5 Hit Testing</h2><p><code>CALayer</code>对响应链一无所知，所以它不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。</p>
<p><strong>注意</strong>：当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变触摸事件被处理的顺序。</p>
<h2 id="3-6__u81EA_u52A8_u5E03_u5C40"><a href="#3-6__u81EA_u52A8_u5E03_u5C40" class="headerlink" title="3.6 自动布局"></a>3.6 自动布局</h2><p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>layoutSublayersOfLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span></span><br></pre></td></tr></table></figure>
<p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<h1 id="u56DB_u3001_u89C6_u89C9_u6548_u679C"><a href="#u56DB_u3001_u89C6_u89C9_u6548_u679C" class="headerlink" title="四、视觉效果"></a>四、视觉效果</h1><h2 id="4-1__u5706_u89D2"><a href="#4-1__u5706_u89D2" class="headerlink" title="4.1 圆角"></a>4.1 圆角</h2><p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。</p>
<h2 id="4-2__u56FE_u5C42_u8FB9_u6846"><a href="#4-2__u56FE_u5C42_u8FB9_u6846" class="headerlink" title="4.2 图层边框"></a>4.2 图层边框</h2><p>CALayer另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。</p>
<p><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0.<code>borderColor</code>定义了边框的颜色，默认为黑色。</p>
<p><code>borderColor</code>是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。边框是跟随图层的边界变化的。</p>
<h2 id="4-3__u9634_u5F71"><a href="#4-3__u9634_u5F71" class="headerlink" title="4.3 阴影"></a>4.3 阴影</h2><p><code>shadowColor</code>属性控制着阴影的颜色，和<code>borderColor</code>和<code>backgroundColor</code>一样，它的类型也是<code>CGColorRef</code>。</p>
<p><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制着阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p><code>shadowRadius</code>属性控制着阴影的<em>模糊度</em>，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。</p>
<h2 id="4-4__u9634_u5F71_u88C1_u526A"><a href="#4-4__u9634_u5F71_u88C1_u526A" class="headerlink" title="4.4 阴影裁剪"></a>4.4 阴影裁剪</h2><p>和图层边框不同，图层的阴影来源于其内容的确切形状，而不是仅仅是边界和<code>cornerRadius</code>。</p>
<p>图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内。</p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。</p>
<h2 id="4-5_shadowPath_u5C5E_u6027"><a href="#4-5_shadowPath_u5C5E_u6027" class="headerlink" title="4.5 shadowPath属性"></a>4.5 <code>shadowPath</code>属性</h2><p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性独立于图层形状之外指定阴影的形状。</p>
<p>实时计算阴影非常消耗资源，可以使用<strong>shadowPath</strong>来提高性能。</p>
<h2 id="4-6__u56FE_u5C42_u8499_u677F"><a href="#4-6__u56FE_u5C42_u8499_u677F" class="headerlink" title="4.6 图层蒙板"></a>4.6 图层蒙板</h2><p>CALayer有一个属性叫做<code>mask</code>。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
<h2 id="4-7__u62C9_u4F38_u8FC7_u6EE4"><a href="#4-7__u62C9_u4F38_u8FC7_u6EE4" class="headerlink" title="4.7 拉伸过滤"></a>4.7 拉伸过滤</h2><p>当图片需要显示不同的大小的时候，有一种叫做<em>拉伸过滤</em>的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p><code>CALayer</code>为此提供了三种拉伸过滤方法:</p>
<ul>
<li>kCAFilterLinear 速度中等</li>
<li>kCAFilterNearest 速度最快，适用于比较小的图或者是差异特别明显，极少斜线的大图</li>
<li>kCAFilterTrilinear 速度最慢</li>
</ul>
<h2 id="4-8__u7EC4_u900F_u660E"><a href="#4-8__u7EC4_u900F_u660E" class="headerlink" title="4.8 组透明"></a>4.8 组透明</h2><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。</p>
<p>整个图层树像一个整体一样的透明效果可以使用：</p>
<ol>
<li>设置Info.plist文件中的<code>UIViewGroupOpacity</code>为YES</li>
<li>设置CALayer的shouldRasterize属性为YES</li>
</ol>
<h1 id="u4E94_u3001_u53D8_u6362"><a href="#u4E94_u3001_u53D8_u6362" class="headerlink" title="五、变换"></a>五、变换</h1><p><code>UIView</code>的<code>transform</code>属性是一个<code>CGAffineTransform</code>类型，用于在二维空间做旋转，缩放和平移。</p>
<p>CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行。</p>
<p>UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer对应于UIView的transform属性叫做affineTransform。</p>
<p>变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<p>CALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。</p>
<h1 id="u516D_u3001_u4E13_u7528_u56FE_u5C42"><a href="#u516D_u3001_u4E13_u7528_u56FE_u5C42" class="headerlink" title="六、专用图层"></a>六、专用图层</h1><h2 id="6-1_CAShapeLayer"><a href="#6-1_CAShapeLayer" class="headerlink" title="6.1 CAShapeLayer"></a>6.1 CAShapeLayer</h2><p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。</p>
<ul>
<li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h2 id="6-2_CATextLayer"><a href="#6-2_CATextLayer" class="headerlink" title="6.2 CATextLayer"></a>6.2 CATextLayer</h2><p>Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>一个UIFont类型，而是一个CFTypeRef类型。这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型（Core Text字体）。</p>
<p>每一个UIView都是寄宿在一个CALayer的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用+layerClass方法，然后用它的返回类型来创建宿主图层。</p>
<p>把CATextLayer作为宿主图层的另一好处就是视图自动设置了contentsScale属性。</p>
<h2 id="6-3_CATransformLayer"><a href="#6-3_CATransformLayer" class="headerlink" title="6.3 CATransformLayer"></a>6.3 CATransformLayer</h2><p>CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构</p>
<h2 id="6-4_CAGradientLayer"><a href="#6-4_CAGradientLayer" class="headerlink" title="6.4 CAGradientLayer"></a>6.4 CAGradientLayer</h2><p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<h2 id="6-5_CAReplicatorLayer"><a href="#6-5_CAReplicatorLayer" class="headerlink" title="6.5 CAReplicatorLayer"></a>6.5 CAReplicatorLayer</h2><p>CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>
<h2 id="6-6_CAScrollLayer"><a href="#6-6_CAScrollLayer" class="headerlink" title="6.6 CAScrollLayer"></a>6.6 CAScrollLayer</h2><p>CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<h2 id="6-7_CATiledLayer"><a href="#6-7_CATiledLayer" class="headerlink" title="6.7 CATiledLayer"></a>6.7 CATiledLayer</h2><p>所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em> 2048，或4096</em> 4096，这个取决于设备型号）。Core Animation强制用CPU处理图片而不是更快的GPU.</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>
<h2 id="6-8_CAEmitterLayer"><a href="#6-8_CAEmitterLayer" class="headerlink" title="6.8 CAEmitterLayer"></a>6.8 CAEmitterLayer</h2><p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<h2 id="6-9_CAEAGLLayer"><a href="#6-9_CAEAGLLayer" class="headerlink" title="6.9 CAEAGLLayer"></a>6.9 CAEAGLLayer</h2><p>当iOS要处理高性能图形绘制，必要时就是OpenGL。OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<h2 id="6-10_AVPlayerLayer"><a href="#6-10_AVPlayerLayer" class="headerlink" title="6.10 AVPlayerLayer"></a>6.10 AVPlayerLayer</h2><p>AVPlayerLayer不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</p>
<p>AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</p>
<p>因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（六）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/06/iOS小知识（六）/" class="article-date">
  	<time datetime="2018-07-06T04:23:51.000Z" itemprop="datePublished">2018-07-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/iOS小知识（六）/">iOS小知识（六）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、UINavigationBar 和 UINavigationItem</p>
<p>UINavigationBar 对于一个navigationController来说是唯一存在的，用来显示UINavigationItem的buttons和views。</p>
<p>每个push进navigationController的viewController都拥有UINavigationItem。UINavigationItem 用于管理UINavigationBar的buttons和views</p>
<p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/12000758-16e4ef9d1fcc4afaa35e4d03dfb3f0aa.png" alt="UINavigationController 层级关系"></p>
<p>2、 在一个VC中，VC.navigationViewController 不能连续push两个VC，若需要连续push，需要操纵navigationViewController 的viewControllers数组。可以参考下列代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *controllers = [self.navigationController.viewControllers mutableCopy];[controllers addObject:secondVc];&#10;[controllers addObject:thirdVC];&#10;[self.navigationController setViewControllers:controllers animated:YES];&#10;/*&#10;&#9;&#36825;&#22359;&#20195;&#30721;&#20250;&#22312;self(firstVC)&#20013;&#30452;&#25509;push&#21040;thirdVC&#12290;&#24403;&#29992;&#25143;&#28857;&#20987;back&#25353;&#38062;&#26102;&#65292;&#20250;&#36864;&#22238;secondVC&#10;*/</span><br></pre></td></tr></table></figure>
<p>3、 RAC的@weakify和@strongify。</p>
<p>​    将@weakify @strongify 宏展开，可以得到以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self) = __weak __typeof_ (self) self_weak = (self);&#10;@strongify(self) = __strong __typeof__(self) self = self_weak_;</span><br></pre></td></tr></table></figure>
<p>​    由于@strongify(self) 重新定义的strongSelf 是self，因此在block中使用ivar时，需注意指明self，否则会导致循环引用。</p>
<p>4、 使用CALayer显示图片时，需注意layer的contents 属性不支持UIImage，需将 UIImage转为CGImage。</p>
<p>5、 transform 会改变frame 的大小，对bounds无影响</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（五）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/28/iOS小知识（五）/" class="article-date">
  	<time datetime="2018-06-28T15:38:48.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/28/iOS小知识（五）/">iOS小知识（五）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001_protocol__u548C_delegate"><a href="#u4E00_u3001_protocol__u548C_delegate" class="headerlink" title="一、 protocol 和 delegate"></a>一、 protocol 和 delegate</h4><p>​    protocol 自己定义，自己实现。遵从该protocol 的ivar，拥有protocol声明的能力。</p>
<p>​    delegate 自己定义，他人实现。自己无法实现某方法时，他人帮你实现。</p>
<h4 id="u4E8C_u3001strong-weak_dance"><a href="#u4E8C_u3001strong-weak_dance" class="headerlink" title="二、strong-weak dance"></a>二、strong-weak dance</h4><p>在block中一开始就执行<code>__strong typeof（weakSelf）strongSelf  =  weakSelf</code>，是为了在block代码执行期间，其他线程 release了weakSelf，不释放weakSelf所指向的对象，只是引用计数-1。但是在block执行之前，weakSelf可能已经释放了，因此，在block中应该先判断strongSelf 是否为nil。避免引起crash。</p>
<h4 id="u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers"><a href="#u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers" class="headerlink" title="三、 Designated Initializers 和 Convenience Initializers"></a>三、 Designated Initializers 和 Convenience Initializers</h4><p>Designated Initializers 可以调super，一般一个类只有一个（且至少有一个），用来完成继承链</p>
<p>Convenience Initializers 不调super，调 self，一个类可以没有</p>
<ul>
<li><p><strong>Rule 1</strong></p>
<p>designated initializer 必须调用其父类的designated initializer</p>
</li>
<li><p><strong>Rule 2</strong></p>
<p>convenience initializer 必须调用本类的initializer方法</p>
</li>
<li><p><strong>Rule 3</strong></p>
<p>convenience initializer 最后必须调用designated initializer</p>
</li>
</ul>
<p><img src="https://docs.swift.org/swift-book/_images/initializerDelegation02_2x.png" alt=""></p>
<h4 id="u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528"><a href="#u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528" class="headerlink" title="四、NSProxy 和 NSObject 方法调用"></a>四、NSProxy 和 NSObject 方法调用</h4><p>​    <strong>NSObejct</strong> </p>
<p>​    1）在本类 method list 中查找selector 。找不到时，沿着继承链查找selector，直到找到为止。若找不到，进入消息派发流程。</p>
<p>​    2）进入消息派发时，本类会调用 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>，其中sel 为selector。在这一步，本类可以使用<code>class_addMethod（）</code> 来动态添加方法处理这个selector，并返回YES表示selector被成功处理。 </p>
<p>​    3）在<code>resolveInstanceMethod:</code> 方法返回NO的情况下，本类会调用</p>
<p><code>- (id)forwardingTargetForSelector:(SEL)sel</code> ，其中sel 为selector。在这一步，本类可以返回一个能够处理该selector的备援对象，表示该备援对象可以处理selector。</p>
<p>​    4）在<code>forwardingTargetForSelector:</code> 方法返回nil的情况下，本类会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code> ，用sel来生成一个NSMethodSignature 对象（携带了selector的参数类型、返回值类型和长度等信息）。在<code>methodSignatureForSelector:</code>的返回值不为nil的情况下，本类调用 <code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，在该方法中，我们可以修改invocation的target，改变selector的receiver。</p>
<p>​    <strong>NSProxy</strong></p>
<p>​    NSProxy对象会直接回调 <code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code></p>
<h4 id="u4E94_u3001UIButton_edgeInset"><a href="#u4E94_u3001UIButton_edgeInset" class="headerlink" title="五、UIButton edgeInset"></a>五、UIButton edgeInset</h4><p><code>contentEdgeInsets:</code> 表示content相对于button矩形的inset/outset，其insets (top, left, bottom, right) 正值将使button矩形的size变大，负值将缩小size。button可以通过这个insets来决定自身的大小。</p>
<p><code>titleEdgeInsets:</code>  表示titleLabel相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel右移/下移，负值将使titleLabel左移/上移。其中的top/bottom 和 left/right 应互为相反数。需要注意的是：insets是在titleLable.text 进行sizetToFits 之后才设置的，因此，正值的inset可能会使text被截断。</p>
<p><code>imageEdgeInsets:</code>  表示imageView相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel右移/下移，负值将使titleLabel左移/上移。其中的top/bottom 和 left/right 应互为相反数。</p>
<p>`</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（四）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/19/iOS小知识（四）/" class="article-date">
  	<time datetime="2018-06-19T08:02:57.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/19/iOS小知识（四）/">iOS小知识（四）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>contentOffset 表示UIScrollView滚动的位置。（其实就是内容视图左上角与scrollView显示视图左上角的间距值）</p>
<p>contentsize：内容显示的尺寸，包括tableheadview。 cell， tableFootView，而且tableview添加子视图的顶点是contentsize的左上角，但如果子视图的起点为-50，则contentsize自动会向上扩展50.</p>
<p>contentInset：附着内容尺寸，在contentsize的四周</p>
<p>contentOffset.y：已滚动的y值，contentsize顶部到目前屏幕的顶部</p>
</li>
<li><p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。</p>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适</p>
</li>
<li><p><code>removeFromSuperview</code>就是一个视图节点删除的操作，执行这个方法，就等于在树形结构中找到该节点，从树型数据结构中删除该节点及其子节点，而并非只是删除该节点自己。同时，另一个操作就是把该对象从响应者链中移除。removeFromSuperview，子视图只remove一次</p>
</li>
<li><p>new 等于 alloc init ，除了alloc 会分配一块相邻的zone来提升程序处理速度。并且，new 实质上隐形的调用了init，alloc init 可以调用更多的初始化函数。因此，在iOS开发中，人们更加习惯于alloc init。</p>
</li>
<li><p><code>addsubview:</code>，子视图只添加一次。多个superView对同一subView执行<code>addSubview:</code>操作，以最后一次为准</p>
</li>
<li><p>block被成员变量引用后，会被copy一份_NSConcreteMallocBlock类型的block。因此，在weakSelf已经释放的情况下，block还能存在。</p>
</li>
<li><p>图片缩放不止可以用手势，也可以用ScrollView</p>
</li>
<li><p>在OC中，不允许直接修改OC对象的结构体属性的成员</p>
</li>
<li><p>Multiple locks on web thread not allowed! Please file a bug. Crashing now… 是因为在子线程中请求了网络</p>
</li>
<li><p>NSBlockOperation只有其内部是并发执行的，其本身还是同步执行</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/11/iOS小知识（三）/" class="article-date">
  	<time datetime="2018-06-11T04:16:54.000Z" itemprop="datePublished">2018-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/11/iOS小知识（三）/">iOS小知识（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001iOS_u54CD_u5E94_u94FE"><a href="#u4E00_u3001iOS_u54CD_u5E94_u94FE" class="headerlink" title="一、iOS响应链"></a>一、iOS响应链</h4><p>​    <code>pointInside:  withEvent:</code>方法是对于目标view的bounds来说的，因此在<code>hitTest: withEvent:</code>方法中需要先用<code>convertPoint: toView:</code> 方法将point坐标转换到目标view上。</p>
<h4 id="u4E8C_u3001free_brige"><a href="#u4E8C_u3001free_brige" class="headerlink" title="二、free brige"></a>二、free brige</h4><ol>
<li><p><code>__bridge</code>，什么也不做，仅仅是转换。此种情况下：<br>(1). 从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。</p>
<p>(2). 从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。</p>
</li>
<li><p><code>__bridge_retained</code>，转换后自动调用CFRetain，即帮助自动解决上述(1)的情形。</p>
</li>
<li><p><code>__bridge_transfer</code>，转换后自动调用CFRelease，即帮助自动解决上述(2)的情形。</p>
</li>
</ol>
<h4 id="u4E09_u3001__u56FE_u7247_u62C9_u4F38"><a href="#u4E09_u3001__u56FE_u7247_u62C9_u4F38" class="headerlink" title="三、 图片拉伸"></a>三、 图片拉伸</h4><p>​    <code>stretchableImageWithLeftCapWidth：topCapHeight:</code>方法可以创建一个内容可拉伸，而边角不拉伸的图片。需要两个参数，第一个是左边不拉伸区域的宽度，第二个参数是上面不拉伸的高度。</p>
<p><code>注意：可拉伸的范围都是距离leftCapWidth后的1竖排像素，和距离topCapHeight后的1横排像素。</code></p>
<h4 id="u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1"><a href="#u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1" class="headerlink" title="四、 tableView: heightForRowAtIndexPath:和tableView: cellForRowAtIndexPath调用顺序的变迁"></a>四、 <code>tableView: heightForRowAtIndexPath:</code>和<code>tableView: cellForRowAtIndexPath</code>调用顺序的变迁</h4><p><strong>iOS  7及之前: </strong></p>
<p> 先依次调一遍heightForRow方法再依次调一遍cellForRow方法，在调cellForRow方法的时候并不会再调一次对应的heightForRow方法。如果我们实现了<code>tableView: estimatedHeightForRowAtIndexPath:</code>给了系统估计高度，那么上述两个方法的执行顺序就会颠倒。并且给定估计高度对于TableView的性能方面也提示不少。</p>
<p><strong>iOS 8  ：</strong></p>
<p>先依次调heightForRow（如果行数超过屏幕依次调用两次，如果行数很少，没有超过屏幕，只依次调用一次），之后每调一次cellForRow的时候又调一次对应的heightForRow方法。</p>
<p><strong>iOS 9和iOS 10:</strong></p>
<p>heightForRow方法会先调用三次，然后每调用一次cellForRow的时候再调用一次对应的heightForRow。</p>
<p><strong>iOS 11 ：</strong></p>
<p> 先row = 0调用一次 cellForRow，然后一次heightForRow.然后再是row =1 ,依次类推。</p>
<h4 id="u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak"><a href="#u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak" class="headerlink" title="五、在Xib中，拖出来的控件为weak"></a>五、在Xib中，拖出来的控件为weak</h4><p>​    IBOutlet的属性一般可以设为weak是因为它已经被IBOutlet.superView引用了，除非IBOutlet.superView被释放，否则IBOutlet的属性也不会被释放。另外IBOutlet属性的生命周期和IBOutlet.superView应该是一致的，所以IBOutlet属性一般设为weak。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/06/iOS小知识（二）/" class="article-date">
  	<time datetime="2018-06-06T04:17:11.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/iOS小知识（二）/">iOS小知识（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001Xcode_u96C6_u6210reveal"><a href="#u4E00_u3001Xcode_u96C6_u6210reveal" class="headerlink" title="一、Xcode集成reveal"></a>一、Xcode集成reveal</h4><ol>
<li>首先打开Terminal，输入<code>vim ~/.lldbinit</code>创建一个名为.lldbinit的文件，然后将如下内容输入到该文件中：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command <span class="keyword">alias</span> reveal_load_sim expr (void*)dlopen(<span class="string">"/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib"</span>, <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_load_dev expr (void*)dlopen([(<span class="constant">NSString</span>*)[(<span class="constant">NSBundle</span>*)[<span class="constant">NSBundle</span> mainBundle]               <span class="symbol">pathForResource:</span>@<span class="string">"libReveal"</span> <span class="symbol">ofType:</span>@<span class="string">"dylib"</span>] <span class="symbol">cStringUsingEncoding:</span><span class="number">0</span>    x4], <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_start expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]           <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStart"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br><span class="line">command <span class="keyword">alias</span> reveal_stop expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]            <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStop"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br></pre></td></tr></table></figure>
<p>​    该步骤其实是为lldb设置了4个别名，为了后续方便操作，这4个别名意义如下：</p>
<p>​    <code>reveal_load_sim</code> 为模拟器加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_load_dev</code> 为真机加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_start</code> 启动<strong>reveal</strong>调试功能</p>
<p>​    <code>reveal_stop</code> 结束<strong>reveal</strong>调试功能</p>
<ol>
<li><p>在AppDelegate类的<code>application:didFinishLaunchingWithOptions:</code>方法中，作如下3步操作：</p>
<p>1) 点击该方法左边的行号区域，增加一个断点，之后右击该断点，选择“Edit Breakpoint”。</p>
<p>2) 点击”Action”项边右的”Add Action”,然后输入“reveal_load_sim”</p>
<p>3) 勾选上Options上的”Automatically continue after evaluating”选项。</p>
</li>
</ol>
<h4 id="u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B"><a href="#u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B" class="headerlink" title="二、Charles 使用教程"></a>二、Charles 使用教程</h4><ol>
<li><p>抓包Https</p>
<p>1) 安装Charles 根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate</p>
<p>2) iOS Simulator 安装根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate in iOS Simulators</p>
<p>3) 设置SSL Host / Port</p>
<p>​    路径： proxy -&gt; SSL Proxying setting -&gt;SSL Proxying</p>
<p>Host/Port 设为*</p>
<p>4) 重启charles</p>
<ol>
<li><h4 id="u5F31_u7F51_u6D4B_u8BD5"><a href="#u5F31_u7F51_u6D4B_u8BD5" class="headerlink" title="弱网测试"></a>弱网测试</h4></li>
</ol>
<p>1) 设置throttle settings</p>
<p>2) 路径： proxy -&gt; throttle settings</p>
<p>3) 根据所需网络环境 Throttle preset 选择弱网环境目标：2G或者3G</p>
</li>
</ol>
<h4 id="u4E09_u3001_u771F_u673Acrash_u5206_u6790"><a href="#u4E09_u3001_u771F_u673Acrash_u5206_u6790" class="headerlink" title="三、真机crash分析"></a>三、真机crash分析</h4><ol>
<li><p>准备好 .crash 文件及.crash 文件所对应的 .dSYM 文件，新建crash文件夹</p>
</li>
<li><p>找到symbolicatecrash路径</p>
<p><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p>
<p>将symbolicatecrash文件复制到crash文件夹</p>
</li>
<li><p>配置developer_dir，cd到crash文件夹</p>
<p><code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></p>
</li>
<li><p>解析crash文件symbolicatecrash</p>
<p><code>./symbolicatecrash /Users/用户名/Desktop/crash/文件名.crash /Users/用户名/Desktop/crash/xxxx（dSYM文件名字）.dSYM &gt; Control_symbol.txt</code></p>
</li>
</ol>
<h4 id="u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5"><a href="#u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5" class="headerlink" title="四、Xcode 断点调试"></a>四、Xcode 断点调试</h4><ol>
<li><p>Exception Breakpoint（异常断点）</p>
<p>当遇到错误，Debug程序会自动定位到栈底信息，即跳到出错代码所在行</p>
</li>
<li><p>Symbolic BreakPoint（符号断点）</p>
<p>根据symbol定位。如 -[XXViewController viewDidLoad]，当 XXViewController 调用 viewDidLoad 时，进行打断。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/01/iOS小知识（一）/" class="article-date">
  	<time datetime="2018-06-01T04:43:22.000Z" itemprop="datePublished">2018-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/01/iOS小知识（一）/">iOS小知识（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>创建 NSDateFormatter，性能较低，使用时应该使用单例，不要每次使用的时候都重新创建。</li>
<li>在 layoutSubviews 中，绝对不能调用setNeedLayout（死循环)，算高方法应该在sizeThatFits中</li>
<li>iPhone SE，iPhone 6 及以下机型都是 @2x，iPhone 6P及以上都是@3x</li>
<li>UIScrollView带有一个 contentInsetAdjustmentBehavior属性，特别是在webView中进行iPhone X 适配的时候，要将其设置为UIScrollViewContentInsetAdjustmentNever</li>
<li><p>iOS7之后，UIScrollView增加了keyboardDismissMode属性，可以设置在scrollView滑动的时候，将键盘关闭。</p>
</li>
<li><p>UIWebView可以跟据链接的来源UIWebViewNavigationType对其操作。</p>
</li>
<li>Runloop 对象是利用字典来进行存储， Key(thread) – Value(loop)</li>
<li>NSNotificationCenter是一个同步的单例模式，而这个通知中心的对象会一直存在于一个应用的生命周期。</li>
<li>勿滥用通知，每次<code>post</code>一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者，这样导致性能降低。</li>
<li>addObserverForName 会生成一个匿名对象，需要remove。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-github-搭建博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/29/hexo-github-搭建博客/" class="article-date">
  	<time datetime="2018-05-29T11:10:47.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/hexo-github-搭建博客/">hexo + github 搭建博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前mac坏了，加上毕业的事情。一直没对blog进行更新，本来以为毕业之后就会有时间来做这事了，可是懒啊Orz……这段时间终于想起这事儿了，但是电脑换了之后，导致重新搭了一次blog，于是重新梳理了一下搭建的过程。</p>
<h4 id="1-_u5B89_u88C5Node-js"><a href="#1-_u5B89_u88C5Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h4><p>​    直接在<a href="https://nodejs.org/en/" target="_blank" rel="external">Node官网</a>下载最新安装包就行了</p>
<h4 id="2-_u5B89_u88C5hexo"><a href="#2-_u5B89_u88C5hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h4><p>​    因为mac本身自带了git，直接在命令行中执行下列命令就好了</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo	/<span class="regexp">/sudo:系统员指令，需输入电脑密码  -g:全局安装</span></span><br></pre></td></tr></table></figure>
<h4 id="3-_u521D_u59CB_u5316"><a href="#3-_u521D_u59CB_u5316" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>​    cd 到安装目录下，执行hexo初始化命令</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> blog	<span class="comment">//blog为创建的hexo安装文件夹</span></span><br></pre></td></tr></table></figure>
<p>​    此时，在blog文件夹中会生成建站所需的全部文件。在blog目录下，安装hexo</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo -<span class="keyword">g</span></span></span><br></pre></td></tr></table></figure>
<p>​    这样，我们就搭建好了本地的blog。可以试试使用如下指令，生成本地blog。在浏览器中输入localhost:4000就可以看到我们的第一个blog了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">s</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_u90E8_u7F72_u5230github"><a href="#4-_u90E8_u7F72_u5230github" class="headerlink" title="4.部署到github"></a>4.部署到github</h4><p>​    申请一个github账号，然后创建一个新的github仓库 userName.github.io</p>
<p>​    然后在_config.yml进行配置，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/userName/userName.github.io.git	//userName你的用户名</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>​    配置好之后，在命令行中执行</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span> -<span class="literal">d</span></span><br></pre></td></tr></table></figure>
<p>​    这样，就将你的blog部署到github上了。</p>
<h4 id="5-_u57DF_u540D_u7ED1_u5B9A"><a href="#5-_u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="5.域名绑定"></a>5.域名绑定</h4><p>​    一般推荐在<a href="https://link.jianshu.com/?t=https://www.godaddy.com" target="_blank" rel="external">goDaddy</a>上购买域名，因为不需要备案……但是图方便的话，可以在阿里万网上买，也比较便宜一点。</p>
<ol>
<li>在blog目录下的CNAME文件中，添加域名信息。然后hexo g -d，部署到github上</li>
</ol>
<ol>
<li><p>注册DNSPod，添加域名。添加CNAME记录为 username.github.io，添加@记录为 username.github.io对应的IP地址</p>
</li>
<li><p>在goDaddy网站上，绑定DNSPod的解析</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1<span class="class">.dnspod</span><span class="class">.net</span>.</span><br><span class="line">f1g1ns2<span class="class">.dnspod</span><span class="class">.net</span>.</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<p>这样，48小时之内，输入我们的域名，就能看到blog上线咯</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>