<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Daniel Young&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Daniel Young's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Daniel Young's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daniel Young's blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Daniel Young&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Daniel Young</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Core-Animation/" style="font-size: 15px;">Core Animation</a> <a href="/tags/iOS小知识/" style="font-size: 20px;">iOS小知识</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/音视频/" style="font-size: 10px;">音视频</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">逗逼一枚…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Daniel Young</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqzfr.com1.z0.glb.clouddn.com/221_FfjKG6931FeJ3e2GkzbG_square.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Daniel Young</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOS-Core-Animation-Advanced-Techniques阅读笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/20/iOS-Core-Animation-Advanced-Techniques阅读笔记（一）/" class="article-date">
  	<time datetime="2018-07-20T04:15:51.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/iOS-Core-Animation-Advanced-Techniques阅读笔记（一）/">iOS Core Animation Advanced Techniques阅读笔记（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="u4E00_u3001_u56FE_u5C42_u6811"><a href="#u4E00_u3001_u56FE_u5C42_u6811" class="headerlink" title="一、图层树"></a>一、图层树</h1><p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。</p>
<h2 id="1-1__u56FE_u5C42_u4E0E_u89C6_u56FE"><a href="#1-1__u56FE_u5C42_u4E0E_u89C6_u56FE" class="headerlink" title="1.1 图层与视图"></a>1.1 图层与视图</h2><p>在iOS当中，所有的视图都从一个叫做<code>UIVIew</code>的基类派生而来，<code>UIView</code>可以处理触摸事件，可以支持基于<em>Core Graphics</em>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<h2 id="1-2_CALayer"><a href="#1-2_CALayer" class="headerlink" title="1.2 CALayer"></a>1.2 CALayer</h2><p><code>CALayer</code>和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。<code>CALayer</code>不知晓具体的响应链，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<h2 id="1-3__u5E73_u884C_u7684_u5C42_u7EA7_u5173_u7CFB"><a href="#1-3__u5E73_u884C_u7684_u5C42_u7EA7_u5173_u7CFB" class="headerlink" title="1.3 平行的层级关系"></a>1.3 平行的层级关系</h2><p>每一个<code>UIview</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。</p>
<p><code>CALayer</code>才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>这个做的原因在于要做职责分离。</p>
<p>在<strong>视图层级</strong>和<strong>图层树</strong>之外，还存在<strong>呈现树</strong>和<strong>渲染树</strong>。</p>
<h2 id="1-4__u56FE_u5C42_u7684_u80FD_u529B"><a href="#1-4__u56FE_u5C42_u7684_u80FD_u529B" class="headerlink" title="1.4 图层的能力"></a>1.4 图层的能力</h2><ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h2 id="1-5__u4F7F_u7528_u56FE_u5C42"><a href="#1-5__u4F7F_u7528_u56FE_u5C42" class="headerlink" title="1.5 使用图层"></a>1.5 使用图层</h2><p>一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层。</p>
<p>使用图层关联的视图而不是<code>CALayer</code>的好处在于，你能在使用所有<code>CALayer</code>底层特性的同时，也可以使用<code>UIView</code>的高级API（比如自动排版，布局和事件处理）。</p>
<h1 id="u4E8C_u3001_u5BC4_u5BBF_u56FE_uFF08_u56FE_u5C42_u5305_u542B_u7684_u56FE_uFF09"><a href="#u4E8C_u3001_u5BC4_u5BBF_u56FE_uFF08_u56FE_u5C42_u5305_u542B_u7684_u56FE_uFF09" class="headerlink" title="二、寄宿图（图层包含的图）"></a>二、寄宿图（图层包含的图）</h1><h2 id="2-1_contents_u5C5E_u6027"><a href="#2-1_contents_u5C5E_u6027" class="headerlink" title="2.1 contents属性"></a>2.1 contents属性</h2><p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。</p>
<p><code>layer.contents = (__bridge id)image.CGImage;</code></p>
<p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。</p>
<h2 id="2-2_contentGravity"><a href="#2-2_contentGravity" class="headerlink" title="2.2 contentGravity"></a>2.2 contentGravity</h2><p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<h2 id="2-3_contentsScale"><a href="#2-3_contentsScale" class="headerlink" title="2.3 contentsScale"></a>2.3 contentsScale</h2><p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p> CGImage没有拉伸的概念。当我们使用UIImage类去读取图片的时候，它读取了Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。</p>
<h2 id="2-4_maskToBounds"><a href="#2-4_maskToBounds" class="headerlink" title="2.4 maskToBounds"></a>2.4 maskToBounds</h2><p>CALayer与<code>clipsToBounds</code>对应的属性为<code>masksToBounds</code></p>
<h2 id="2-5_contentsRect"><a href="#2-5_contentsRect" class="headerlink" title="2.5 contentsRect"></a>2.5 contentsRect</h2><p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。</p>
<p><code>contentsRect</code>不是按点来计算的，它使用了<em>单位坐标</em>，单位坐标指定在0到1之间，是一个相对值。默认的<code>contentsRect</code>是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。</p>
<p>iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准清晰度的设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是它们在处理图片时仍然是相关的。UIImage可以识别屏幕分辨，并以点为单位指定其大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，它们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<h2 id="2-6_contentsCenter"><a href="#2-6_contentsCenter" class="headerlink" title="2.6 contentsCenter"></a>2.6 contentsCenter</h2><p><code>contentsCenter</code>其实是一个CGRect，它定义了图层中的可拉伸区域和一个固定的边框。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<h2 id="2-7_Custome_Drawing"><a href="#2-7_Custome_Drawing" class="headerlink" title="2.7 Custome Drawing"></a>2.7 Custome Drawing</h2><p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p>如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>需要注意的是：</p>
<ul>
<li>不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<h1 id="u4E09_u3001_u56FE_u50CF_u51E0_u4F55_u5B66"><a href="#u4E09_u3001_u56FE_u50CF_u51E0_u4F55_u5B66" class="headerlink" title="三、图像几何学"></a>三、图像几何学</h1><h2 id="3-1__u5E03_u5C40"><a href="#3-1__u5E03_u5C40" class="headerlink" title="3.1 布局"></a>3.1 布局</h2><p>UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p><code>frame</code>代表了图层的外部坐标（也就是在父图层上占据的空间），<code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角），<code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。</p>
<p>视图的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是<em>存取方法</em>，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方<code>CALayer</code>的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p>对于视图或者图层来说，<code>frame</code>并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值。</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（在旋转中，layer和view俩者bounds保持不变，frame改变）</p>
<h2 id="3-2__u951A_u70B9"><a href="#3-2__u951A_u70B9" class="headerlink" title="3.2 锚点"></a>3.2 锚点</h2><p>图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的<em>把柄</em>。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被<code>UIView</code>接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动，而不是居中了。当CALayer的anchorPoint改变时，其frame随之改变，而position保存不变。</p>
<h2 id="3-3__u7FFB_u8F6C_u7684_u51E0_u4F55_u7ED3_u6784"><a href="#3-3__u7FFB_u8F6C_u7684_u51E0_u4F55_u7ED3_u6784" class="headerlink" title="3.3 翻转的几何结构"></a>3.3 翻转的几何结构</h2><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为<code>YES</code>意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部。</p>
<h2 id="3-4_Z_u5750_u6807_u8F74"><a href="#3-4_Z_u5750_u6807_u8F74" class="headerlink" title="3.4 Z坐标轴"></a>3.4 Z坐标轴</h2><p>和<code>UIView</code>严格的二维坐标系不同，<code>CALayer</code>存在于一个三维空间当中。除了我们已经讨论过的<code>position</code>和<code>anchorPoint</code>属性之外，<code>CALayer</code>还有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p><code>zPosition</code>最实用的功能就是改变图层的<em>显示顺序</em>了。通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的，这就是所谓的<strong>画家的算法</strong></p>
<h2 id="3-5_Hit_Testing"><a href="#3-5_Hit_Testing" class="headerlink" title="3.5 Hit Testing"></a>3.5 Hit Testing</h2><p><code>CALayer</code>对响应链一无所知，所以它不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回<code>YES</code>。</p>
<p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。</p>
<p><strong>注意</strong>：当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变触摸事件被处理的顺序。</p>
<h2 id="3-6__u81EA_u52A8_u5E03_u5C40"><a href="#3-6__u81EA_u52A8_u5E03_u5C40" class="headerlink" title="3.6 自动布局"></a>3.6 自动布局</h2><p>当使用视图的时候，可以充分利用<code>UIView</code>类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraint</code>API，但如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>layoutSublayersOfLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span></span><br></pre></td></tr></table></figure>
<p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<h1 id="u56DB_u3001_u89C6_u89C9_u6548_u679C"><a href="#u56DB_u3001_u89C6_u89C9_u6548_u679C" class="headerlink" title="四、视觉效果"></a>四、视觉效果</h1><h2 id="4-1__u5706_u89D2"><a href="#4-1__u5706_u89D2" class="headerlink" title="4.1 圆角"></a>4.1 圆角</h2><p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把<code>masksToBounds</code>设置成YES的话，图层里面的所有东西都会被截取。</p>
<h2 id="4-2__u56FE_u5C42_u8FB9_u6846"><a href="#4-2__u56FE_u5C42_u8FB9_u6846" class="headerlink" title="4.2 图层边框"></a>4.2 图层边框</h2><p>CALayer另外两个非常有用属性就是<code>borderWidth</code>和<code>borderColor</code>。二者共同定义了图层边的绘制样式。</p>
<p><code>borderWidth</code>是以点为单位的定义边框粗细的浮点数，默认为0.<code>borderColor</code>定义了边框的颜色，默认为黑色。</p>
<p><code>borderColor</code>是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。边框是跟随图层的边界变化的。</p>
<h2 id="4-3__u9634_u5F71"><a href="#4-3__u9634_u5F71" class="headerlink" title="4.3 阴影"></a>4.3 阴影</h2><p><code>shadowColor</code>属性控制着阴影的颜色，和<code>borderColor</code>和<code>backgroundColor</code>一样，它的类型也是<code>CGColorRef</code>。</p>
<p><code>shadowOffset</code>属性控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制着阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p><code>shadowRadius</code>属性控制着阴影的<em>模糊度</em>，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。</p>
<h2 id="4-4__u9634_u5F71_u88C1_u526A"><a href="#4-4__u9634_u5F71_u88C1_u526A" class="headerlink" title="4.4 阴影裁剪"></a>4.4 阴影裁剪</h2><p>和图层边框不同，图层的阴影来源于其内容的确切形状，而不是仅仅是边界和<code>cornerRadius</code>。</p>
<p>图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内。</p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。</p>
<h2 id="4-5_shadowPath_u5C5E_u6027"><a href="#4-5_shadowPath_u5C5E_u6027" class="headerlink" title="4.5 shadowPath属性"></a>4.5 <code>shadowPath</code>属性</h2><p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code>是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性独立于图层形状之外指定阴影的形状。</p>
<p>实时计算阴影非常消耗资源，可以使用<strong>shadowPath</strong>来提高性能。</p>
<h2 id="4-6__u56FE_u5C42_u8499_u677F"><a href="#4-6__u56FE_u5C42_u8499_u677F" class="headerlink" title="4.6 图层蒙板"></a>4.6 图层蒙板</h2><p>CALayer有一个属性叫做<code>mask</code>。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>mask</code>图层定义了父图层的部分可见区域。</p>
<h2 id="4-7__u62C9_u4F38_u8FC7_u6EE4"><a href="#4-7__u62C9_u4F38_u8FC7_u6EE4" class="headerlink" title="4.7 拉伸过滤"></a>4.7 拉伸过滤</h2><p>当图片需要显示不同的大小的时候，有一种叫做<em>拉伸过滤</em>的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p><code>CALayer</code>为此提供了三种拉伸过滤方法:</p>
<ul>
<li>kCAFilterLinear 速度中等</li>
<li>kCAFilterNearest 速度最快，适用于比较小的图或者是差异特别明显，极少斜线的大图</li>
<li>kCAFilterTrilinear 速度最慢</li>
</ul>
<h2 id="4-8__u7EC4_u900F_u660E"><a href="#4-8__u7EC4_u900F_u660E" class="headerlink" title="4.8 组透明"></a>4.8 组透明</h2><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。</p>
<p>整个图层树像一个整体一样的透明效果可以使用：</p>
<ol>
<li>设置Info.plist文件中的<code>UIViewGroupOpacity</code>为YES</li>
<li>设置CALayer的shouldRasterize属性为YES</li>
</ol>
<h1 id="u4E94_u3001_u53D8_u6362"><a href="#u4E94_u3001_u53D8_u6362" class="headerlink" title="五、变换"></a>五、变换</h1><p><code>UIView</code>的<code>transform</code>属性是一个<code>CGAffineTransform</code>类型，用于在二维空间做旋转，缩放和平移。</p>
<p>CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行。</p>
<p>UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer对应于UIView的transform属性叫做affineTransform。</p>
<p>变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<p>CALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。</p>
<h1 id="u516D_u3001_u4E13_u7528_u56FE_u5C42"><a href="#u516D_u3001_u4E13_u7528_u56FE_u5C42" class="headerlink" title="六、专用图层"></a>六、专用图层</h1><h2 id="6-1_CAShapeLayer"><a href="#6-1_CAShapeLayer" class="headerlink" title="6.1 CAShapeLayer"></a>6.1 CAShapeLayer</h2><p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。</p>
<ul>
<li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h2 id="6-2_CATextLayer"><a href="#6-2_CATextLayer" class="headerlink" title="6.2 CATextLayer"></a>6.2 CATextLayer</h2><p>Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>一个UIFont类型，而是一个CFTypeRef类型。这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型（Core Text字体）。</p>
<p>每一个UIView都是寄宿在一个CALayer的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用+layerClass方法，然后用它的返回类型来创建宿主图层。</p>
<p>把CATextLayer作为宿主图层的另一好处就是视图自动设置了contentsScale属性。</p>
<h2 id="6-3_CATransformLayer"><a href="#6-3_CATransformLayer" class="headerlink" title="6.3 CATransformLayer"></a>6.3 CATransformLayer</h2><p>CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构</p>
<h2 id="6-4_CAGradientLayer"><a href="#6-4_CAGradientLayer" class="headerlink" title="6.4 CAGradientLayer"></a>6.4 CAGradientLayer</h2><p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<h2 id="6-5_CAReplicatorLayer"><a href="#6-5_CAReplicatorLayer" class="headerlink" title="6.5 CAReplicatorLayer"></a>6.5 CAReplicatorLayer</h2><p>CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>
<h2 id="6-6_CAScrollLayer"><a href="#6-6_CAScrollLayer" class="headerlink" title="6.6 CAScrollLayer"></a>6.6 CAScrollLayer</h2><p>CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<h2 id="6-7_CATiledLayer"><a href="#6-7_CATiledLayer" class="headerlink" title="6.7 CATiledLayer"></a>6.7 CATiledLayer</h2><p>所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em> 2048，或4096</em> 4096，这个取决于设备型号）。Core Animation强制用CPU处理图片而不是更快的GPU.</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>
<h2 id="6-8_CAEmitterLayer"><a href="#6-8_CAEmitterLayer" class="headerlink" title="6.8 CAEmitterLayer"></a>6.8 CAEmitterLayer</h2><p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<h2 id="6-9_CAEAGLLayer"><a href="#6-9_CAEAGLLayer" class="headerlink" title="6.9 CAEAGLLayer"></a>6.9 CAEAGLLayer</h2><p>当iOS要处理高性能图形绘制，必要时就是OpenGL。OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<h2 id="6-10_AVPlayerLayer"><a href="#6-10_AVPlayerLayer" class="headerlink" title="6.10 AVPlayerLayer"></a>6.10 AVPlayerLayer</h2><p>AVPlayerLayer不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</p>
<p>AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</p>
<p>因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Core-Animation/">Core Animation</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（六）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/06/iOS小知识（六）/" class="article-date">
  	<time datetime="2018-07-06T04:23:51.000Z" itemprop="datePublished">2018-07-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/iOS小知识（六）/">iOS小知识（六）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、UINavigationBar 和 UINavigationItem</p>
<p>UINavigationBar 对于一个navigationController来说是唯一存在的，用来显示UINavigationItem的buttons和views。</p>
<p>每个push进navigationController的viewController都拥有UINavigationItem。UINavigationItem 用于管理UINavigationBar的buttons和views</p>
<p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/12000758-16e4ef9d1fcc4afaa35e4d03dfb3f0aa.png" alt="UINavigationController 层级关系"></p>
<p>2、 在一个VC中，VC.navigationViewController 不能连续push两个VC，若需要连续push，需要操纵navigationViewController 的viewControllers数组。可以参考下列代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *controllers = [self.navigationController.viewControllers mutableCopy];[controllers addObject:secondVc];&#10;[controllers addObject:thirdVC];&#10;[self.navigationController setViewControllers:controllers animated:YES];&#10;/*&#10;&#9;&#36825;&#22359;&#20195;&#30721;&#20250;&#22312;self(firstVC)&#20013;&#30452;&#25509;push&#21040;thirdVC&#12290;&#24403;&#29992;&#25143;&#28857;&#20987;back&#25353;&#38062;&#26102;&#65292;&#20250;&#36864;&#22238;secondVC&#10;*/</span><br></pre></td></tr></table></figure>
<p>3、 RAC的@weakify和@strongify。</p>
<p>​    将@weakify @strongify 宏展开，可以得到以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self) = __weak __typeof_ (self) self_weak = (self);&#10;@strongify(self) = __strong __typeof__(self) self = self_weak_;</span><br></pre></td></tr></table></figure>
<p>​    由于@strongify(self) 重新定义的strongSelf 是self，因此在block中使用ivar时，需注意指明self，否则会导致循环引用。</p>
<p>4、 使用CALayer显示图片时，需注意layer的contents 属性不支持UIImage，需将 UIImage转为CGImage。</p>
<p>5、 transform 会改变frame 的大小，对bounds无影响</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（五）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/28/iOS小知识（五）/" class="article-date">
  	<time datetime="2018-06-28T15:38:48.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/28/iOS小知识（五）/">iOS小知识（五）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001_protocol__u548C_delegate"><a href="#u4E00_u3001_protocol__u548C_delegate" class="headerlink" title="一、 protocol 和 delegate"></a>一、 protocol 和 delegate</h4><p>​    protocol 自己定义，自己实现。遵从该protocol 的ivar，拥有protocol声明的能力。</p>
<p>​    delegate 自己定义，他人实现。自己无法实现某方法时，他人帮你实现。</p>
<h4 id="u4E8C_u3001strong-weak_dance"><a href="#u4E8C_u3001strong-weak_dance" class="headerlink" title="二、strong-weak dance"></a>二、strong-weak dance</h4><p>在block中一开始就执行<code>__strong typeof（weakSelf）strongSelf  =  weakSelf</code>，是为了在block代码执行期间，其他线程 release了weakSelf，不释放weakSelf所指向的对象，只是引用计数-1。但是在block执行之前，weakSelf可能已经释放了，因此，在block中应该先判断strongSelf 是否为nil。避免引起crash。</p>
<h4 id="u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers"><a href="#u4E09_u3001_Designated_Initializers__u548C_Convenience_Initializers" class="headerlink" title="三、 Designated Initializers 和 Convenience Initializers"></a>三、 Designated Initializers 和 Convenience Initializers</h4><p>Designated Initializers 可以调super，一般一个类只有一个（且至少有一个），用来完成继承链</p>
<p>Convenience Initializers 不调super，调 self，一个类可以没有</p>
<ul>
<li><p><strong>Rule 1</strong></p>
<p>designated initializer 必须调用其父类的designated initializer</p>
</li>
<li><p><strong>Rule 2</strong></p>
<p>convenience initializer 必须调用本类的initializer方法</p>
</li>
<li><p><strong>Rule 3</strong></p>
<p>convenience initializer 最后必须调用designated initializer</p>
</li>
</ul>
<p><img src="https://docs.swift.org/swift-book/_images/initializerDelegation02_2x.png" alt=""></p>
<h4 id="u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528"><a href="#u56DB_u3001NSProxy__u548C_NSObject__u65B9_u6CD5_u8C03_u7528" class="headerlink" title="四、NSProxy 和 NSObject 方法调用"></a>四、NSProxy 和 NSObject 方法调用</h4><p>​    <strong>NSObejct</strong> </p>
<p>​    1）在本类 method list 中查找selector 。找不到时，沿着继承链查找selector，直到找到为止。若找不到，进入消息派发流程。</p>
<p>​    2）进入消息派发时，本类会调用 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>，其中sel 为selector。在这一步，本类可以使用<code>class_addMethod（）</code> 来动态添加方法处理这个selector，并返回YES表示selector被成功处理。 </p>
<p>​    3）在<code>resolveInstanceMethod:</code> 方法返回NO的情况下，本类会调用</p>
<p><code>- (id)forwardingTargetForSelector:(SEL)sel</code> ，其中sel 为selector。在这一步，本类可以返回一个能够处理该selector的备援对象，表示该备援对象可以处理selector。</p>
<p>​    4）在<code>forwardingTargetForSelector:</code> 方法返回nil的情况下，本类会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</code> ，用sel来生成一个NSMethodSignature 对象（携带了selector的参数类型、返回值类型和长度等信息）。在<code>methodSignatureForSelector:</code>的返回值不为nil的情况下，本类调用 <code>- (void)forwardInvocation:(NSInvocation *)invocation</code>，在该方法中，我们可以修改invocation的target，改变selector的receiver。</p>
<p>​    <strong>NSProxy</strong></p>
<p>​    NSProxy对象会直接回调 <code>-methodSignatureForSelector:</code>/<code>-forwardInvocation:</code></p>
<h4 id="u4E94_u3001UIButton_edgeInset"><a href="#u4E94_u3001UIButton_edgeInset" class="headerlink" title="五、UIButton edgeInset"></a>五、UIButton edgeInset</h4><p><code>contentEdgeInsets:</code> 表示content相对于button矩形的inset/outset，其insets (top, left, bottom, right) 正值将使button矩形的size变大，负值将缩小size。button可以通过这个insets来决定自身的大小。</p>
<p><code>titleEdgeInsets:</code>  表示titleLabel相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel右移/下移，负值将使titleLabel左移/上移。其中的top/bottom 和 left/right 应互为相反数。需要注意的是：insets是在titleLable.text 进行sizetToFits 之后才设置的，因此，正值的inset可能会使text被截断。</p>
<p><code>imageEdgeInsets:</code>  表示imageView相对于原frame的inset/outset，其insets (top, left, bottom, right) 正值将使titleLabel右移/下移，负值将使titleLabel左移/上移。其中的top/bottom 和 left/right 应互为相反数。</p>
<p>`</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（四）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/19/iOS小知识（四）/" class="article-date">
  	<time datetime="2018-06-19T08:02:57.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/19/iOS小知识（四）/">iOS小知识（四）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>contentOffset 表示UIScrollView滚动的位置。（其实就是内容视图左上角与scrollView显示视图左上角的间距值）</p>
<p>contentsize：内容显示的尺寸，包括tableheadview。 cell， tableFootView，而且tableview添加子视图的顶点是contentsize的左上角，但如果子视图的起点为-50，则contentsize自动会向上扩展50.</p>
<p>contentInset：附着内容尺寸，在contentsize的四周</p>
<p>contentOffset.y：已滚动的y值，contentsize顶部到目前屏幕的顶部</p>
</li>
<li><p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适。</p>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适</p>
</li>
<li><p><code>removeFromSuperview</code>就是一个视图节点删除的操作，执行这个方法，就等于在树形结构中找到该节点，从树型数据结构中删除该节点及其子节点，而并非只是删除该节点自己。同时，另一个操作就是把该对象从响应者链中移除。removeFromSuperview，子视图只remove一次</p>
</li>
<li><p>new 等于 alloc init ，除了alloc 会分配一块相邻的zone来提升程序处理速度。并且，new 实质上隐形的调用了init，alloc init 可以调用更多的初始化函数。因此，在iOS开发中，人们更加习惯于alloc init。</p>
</li>
<li><p><code>addsubview:</code>，子视图只添加一次。多个superView对同一subView执行<code>addSubview:</code>操作，以最后一次为准</p>
</li>
<li><p>block被成员变量引用后，会被copy一份_NSConcreteMallocBlock类型的block。因此，在weakSelf已经释放的情况下，block还能存在。</p>
</li>
<li><p>图片缩放不止可以用手势，也可以用ScrollView</p>
</li>
<li><p>在OC中，不允许直接修改OC对象的结构体属性的成员</p>
</li>
<li><p>Multiple locks on web thread not allowed! Please file a bug. Crashing now… 是因为在子线程中请求了网络</p>
</li>
<li><p>NSBlockOperation只有其内部是并发执行的，其本身还是同步执行</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/11/iOS小知识（三）/" class="article-date">
  	<time datetime="2018-06-11T04:16:54.000Z" itemprop="datePublished">2018-06-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/11/iOS小知识（三）/">iOS小知识（三）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001iOS_u54CD_u5E94_u94FE"><a href="#u4E00_u3001iOS_u54CD_u5E94_u94FE" class="headerlink" title="一、iOS响应链"></a>一、iOS响应链</h4><p>​    <code>pointInside:  withEvent:</code>方法是对于目标view的bounds来说的，因此在<code>hitTest: withEvent:</code>方法中需要先用<code>convertPoint: toView:</code> 方法将point坐标转换到目标view上。</p>
<h4 id="u4E8C_u3001free_brige"><a href="#u4E8C_u3001free_brige" class="headerlink" title="二、free brige"></a>二、free brige</h4><ol>
<li><p><code>__bridge</code>，什么也不做，仅仅是转换。此种情况下：<br>(1). 从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。</p>
<p>(2). 从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。</p>
</li>
<li><p><code>__bridge_retained</code>，转换后自动调用CFRetain，即帮助自动解决上述(1)的情形。</p>
</li>
<li><p><code>__bridge_transfer</code>，转换后自动调用CFRelease，即帮助自动解决上述(2)的情形。</p>
</li>
</ol>
<h4 id="u4E09_u3001__u56FE_u7247_u62C9_u4F38"><a href="#u4E09_u3001__u56FE_u7247_u62C9_u4F38" class="headerlink" title="三、 图片拉伸"></a>三、 图片拉伸</h4><p>​    <code>stretchableImageWithLeftCapWidth：topCapHeight:</code>方法可以创建一个内容可拉伸，而边角不拉伸的图片。需要两个参数，第一个是左边不拉伸区域的宽度，第二个参数是上面不拉伸的高度。</p>
<p><code>注意：可拉伸的范围都是距离leftCapWidth后的1竖排像素，和距离topCapHeight后的1横排像素。</code></p>
<h4 id="u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1"><a href="#u56DB_u3001_tableView_3A_heightForRowAtIndexPath_3A_u548CtableView_3A_cellForRowAtIndexPath_u8C03_u7528_u987A_u5E8F_u7684_u53D8_u8FC1" class="headerlink" title="四、 tableView: heightForRowAtIndexPath:和tableView: cellForRowAtIndexPath调用顺序的变迁"></a>四、 <code>tableView: heightForRowAtIndexPath:</code>和<code>tableView: cellForRowAtIndexPath</code>调用顺序的变迁</h4><p><strong>iOS  7及之前: </strong></p>
<p> 先依次调一遍heightForRow方法再依次调一遍cellForRow方法，在调cellForRow方法的时候并不会再调一次对应的heightForRow方法。如果我们实现了<code>tableView: estimatedHeightForRowAtIndexPath:</code>给了系统估计高度，那么上述两个方法的执行顺序就会颠倒。并且给定估计高度对于TableView的性能方面也提示不少。</p>
<p><strong>iOS 8  ：</strong></p>
<p>先依次调heightForRow（如果行数超过屏幕依次调用两次，如果行数很少，没有超过屏幕，只依次调用一次），之后每调一次cellForRow的时候又调一次对应的heightForRow方法。</p>
<p><strong>iOS 9和iOS 10:</strong></p>
<p>heightForRow方法会先调用三次，然后每调用一次cellForRow的时候再调用一次对应的heightForRow。</p>
<p><strong>iOS 11 ：</strong></p>
<p> 先row = 0调用一次 cellForRow，然后一次heightForRow.然后再是row =1 ,依次类推。</p>
<h4 id="u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak"><a href="#u4E94_u3001_u5728Xib_u4E2D_uFF0C_u62D6_u51FA_u6765_u7684_u63A7_u4EF6_u4E3Aweak" class="headerlink" title="五、在Xib中，拖出来的控件为weak"></a>五、在Xib中，拖出来的控件为weak</h4><p>​    IBOutlet的属性一般可以设为weak是因为它已经被IBOutlet.superView引用了，除非IBOutlet.superView被释放，否则IBOutlet的属性也不会被释放。另外IBOutlet属性的生命周期和IBOutlet.superView应该是一致的，所以IBOutlet属性一般设为weak。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/06/iOS小知识（二）/" class="article-date">
  	<time datetime="2018-06-06T04:17:11.000Z" itemprop="datePublished">2018-06-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/iOS小知识（二）/">iOS小知识（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="u4E00_u3001Xcode_u96C6_u6210reveal"><a href="#u4E00_u3001Xcode_u96C6_u6210reveal" class="headerlink" title="一、Xcode集成reveal"></a>一、Xcode集成reveal</h4><ol>
<li>首先打开Terminal，输入<code>vim ~/.lldbinit</code>创建一个名为.lldbinit的文件，然后将如下内容输入到该文件中：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command <span class="keyword">alias</span> reveal_load_sim expr (void*)dlopen(<span class="string">"/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib"</span>, <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_load_dev expr (void*)dlopen([(<span class="constant">NSString</span>*)[(<span class="constant">NSBundle</span>*)[<span class="constant">NSBundle</span> mainBundle]               <span class="symbol">pathForResource:</span>@<span class="string">"libReveal"</span> <span class="symbol">ofType:</span>@<span class="string">"dylib"</span>] <span class="symbol">cStringUsingEncoding:</span><span class="number">0</span>    x4], <span class="number">0x2</span>);</span><br><span class="line">command <span class="keyword">alias</span> reveal_start expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]           <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStart"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br><span class="line">command <span class="keyword">alias</span> reveal_stop expr (void)[(<span class="constant">NSNotificationCenter</span>*)[<span class="constant">NSNotificationCenter</span> defaultCenter]            <span class="symbol">postNotificationName:</span>@<span class="string">"IBARevealRequestStop"</span> <span class="symbol">object:</span><span class="keyword">nil</span>];</span><br></pre></td></tr></table></figure>
<p>​    该步骤其实是为lldb设置了4个别名，为了后续方便操作，这4个别名意义如下：</p>
<p>​    <code>reveal_load_sim</code> 为模拟器加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_load_dev</code> 为真机加载<strong>reveal</strong>调试用的动态链接库</p>
<p>​    <code>reveal_start</code> 启动<strong>reveal</strong>调试功能</p>
<p>​    <code>reveal_stop</code> 结束<strong>reveal</strong>调试功能</p>
<ol>
<li><p>在AppDelegate类的<code>application:didFinishLaunchingWithOptions:</code>方法中，作如下3步操作：</p>
<p>1) 点击该方法左边的行号区域，增加一个断点，之后右击该断点，选择“Edit Breakpoint”。</p>
<p>2) 点击”Action”项边右的”Add Action”,然后输入“reveal_load_sim”</p>
<p>3) 勾选上Options上的”Automatically continue after evaluating”选项。</p>
</li>
</ol>
<h4 id="u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B"><a href="#u4E8C_u3001Charles__u4F7F_u7528_u6559_u7A0B" class="headerlink" title="二、Charles 使用教程"></a>二、Charles 使用教程</h4><ol>
<li><p>抓包Https</p>
<p>1) 安装Charles 根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate</p>
<p>2) iOS Simulator 安装根证书</p>
<p>​    路径： help -&gt; SSL Proxying -&gt; install Charles Root Certificate in iOS Simulators</p>
<p>3) 设置SSL Host / Port</p>
<p>​    路径： proxy -&gt; SSL Proxying setting -&gt;SSL Proxying</p>
<p>Host/Port 设为*</p>
<p>4) 重启charles</p>
<ol>
<li><h4 id="u5F31_u7F51_u6D4B_u8BD5"><a href="#u5F31_u7F51_u6D4B_u8BD5" class="headerlink" title="弱网测试"></a>弱网测试</h4></li>
</ol>
<p>1) 设置throttle settings</p>
<p>2) 路径： proxy -&gt; throttle settings</p>
<p>3) 根据所需网络环境 Throttle preset 选择弱网环境目标：2G或者3G</p>
</li>
</ol>
<h4 id="u4E09_u3001_u771F_u673Acrash_u5206_u6790"><a href="#u4E09_u3001_u771F_u673Acrash_u5206_u6790" class="headerlink" title="三、真机crash分析"></a>三、真机crash分析</h4><ol>
<li><p>准备好 .crash 文件及.crash 文件所对应的 .dSYM 文件，新建crash文件夹</p>
</li>
<li><p>找到symbolicatecrash路径</p>
<p><code>find /Applications/Xcode.app -name symbolicatecrash -type f</code></p>
<p>将symbolicatecrash文件复制到crash文件夹</p>
</li>
<li><p>配置developer_dir，cd到crash文件夹</p>
<p><code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></p>
</li>
<li><p>解析crash文件symbolicatecrash</p>
<p><code>./symbolicatecrash /Users/用户名/Desktop/crash/文件名.crash /Users/用户名/Desktop/crash/xxxx（dSYM文件名字）.dSYM &gt; Control_symbol.txt</code></p>
</li>
</ol>
<h4 id="u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5"><a href="#u56DB_u3001Xcode__u65AD_u70B9_u8C03_u8BD5" class="headerlink" title="四、Xcode 断点调试"></a>四、Xcode 断点调试</h4><ol>
<li><p>Exception Breakpoint（异常断点）</p>
<p>当遇到错误，Debug程序会自动定位到栈底信息，即跳到出错代码所在行</p>
</li>
<li><p>Symbolic BreakPoint（符号断点）</p>
<p>根据symbol定位。如 -[XXViewController viewDidLoad]，当 XXViewController 调用 viewDidLoad 时，进行打断。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS小知识（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/01/iOS小知识（一）/" class="article-date">
  	<time datetime="2018-06-01T04:43:22.000Z" itemprop="datePublished">2018-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/01/iOS小知识（一）/">iOS小知识（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>创建 NSDateFormatter，性能较低，使用时应该使用单例，不要每次使用的时候都重新创建。</li>
<li>在 layoutSubviews 中，绝对不能调用setNeedLayout（死循环)，算高方法应该在sizeThatFits中</li>
<li>iPhone SE，iPhone 6 及以下机型都是 @2x，iPhone 6P及以上都是@3x</li>
<li>UIScrollView带有一个 contentInsetAdjustmentBehavior属性，特别是在webView中进行iPhone X 适配的时候，要将其设置为UIScrollViewContentInsetAdjustmentNever</li>
<li><p>iOS7之后，UIScrollView增加了keyboardDismissMode属性，可以设置在scrollView滑动的时候，将键盘关闭。</p>
</li>
<li><p>UIWebView可以跟据链接的来源UIWebViewNavigationType对其操作。</p>
</li>
<li>Runloop 对象是利用字典来进行存储， Key(thread) – Value(loop)</li>
<li>NSNotificationCenter是一个同步的单例模式，而这个通知中心的对象会一直存在于一个应用的生命周期。</li>
<li>勿滥用通知，每次<code>post</code>一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者，这样导致性能降低。</li>
<li>addObserverForName 会生成一个匿名对象，需要remove。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS小知识/">iOS小知识</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-github-搭建博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/29/hexo-github-搭建博客/" class="article-date">
  	<time datetime="2018-05-29T11:10:47.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/hexo-github-搭建博客/">hexo + github 搭建博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>之前mac坏了，加上毕业的事情。一直没对blog进行更新，本来以为毕业之后就会有时间来做这事了，可是懒啊Orz……这段时间终于想起这事儿了，但是电脑换了之后，导致重新搭了一次blog，于是重新梳理了一下搭建的过程。</p>
<h4 id="1-_u5B89_u88C5Node-js"><a href="#1-_u5B89_u88C5Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h4><p>​    直接在<a href="https://nodejs.org/en/" target="_blank" rel="external">Node官网</a>下载最新安装包就行了</p>
<h4 id="2-_u5B89_u88C5hexo"><a href="#2-_u5B89_u88C5hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h4><p>​    因为mac本身自带了git，直接在命令行中执行下列命令就好了</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo	/<span class="regexp">/sudo:系统员指令，需输入电脑密码  -g:全局安装</span></span><br></pre></td></tr></table></figure>
<h4 id="3-_u521D_u59CB_u5316"><a href="#3-_u521D_u59CB_u5316" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>​    cd 到安装目录下，执行hexo初始化命令</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> blog	<span class="comment">//blog为创建的hexo安装文件夹</span></span><br></pre></td></tr></table></figure>
<p>​    此时，在blog文件夹中会生成建站所需的全部文件。在blog目录下，安装hexo</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo -<span class="keyword">g</span></span></span><br></pre></td></tr></table></figure>
<p>​    这样，我们就搭建好了本地的blog。可以试试使用如下指令，生成本地blog。在浏览器中输入localhost:4000就可以看到我们的第一个blog了。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">s</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_u90E8_u7F72_u5230github"><a href="#4-_u90E8_u7F72_u5230github" class="headerlink" title="4.部署到github"></a>4.部署到github</h4><p>​    申请一个github账号，然后创建一个新的github仓库 userName.github.io</p>
<p>​    然后在_config.yml进行配置，</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/userName/userName.github.io.git	//userName你的用户名</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>​    配置好之后，在命令行中执行</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span> -<span class="literal">d</span></span><br></pre></td></tr></table></figure>
<p>​    这样，就将你的blog部署到github上了。</p>
<h4 id="5-_u57DF_u540D_u7ED1_u5B9A"><a href="#5-_u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="5.域名绑定"></a>5.域名绑定</h4><p>​    一般推荐在<a href="https://link.jianshu.com/?t=https://www.godaddy.com" target="_blank" rel="external">goDaddy</a>上购买域名，因为不需要备案……但是图方便的话，可以在阿里万网上买，也比较便宜一点。</p>
<ol>
<li>在blog目录下的CNAME文件中，添加域名信息。然后hexo g -d，部署到github上</li>
</ol>
<ol>
<li><p>注册DNSPod，添加域名。添加CNAME记录为 username.github.io，添加@记录为 username.github.io对应的IP地址</p>
</li>
<li><p>在goDaddy网站上，绑定DNSPod的解析</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1<span class="class">.dnspod</span><span class="class">.net</span>.</span><br><span class="line">f1g1ns2<span class="class">.dnspod</span><span class="class">.net</span>.</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<p>这样，48小时之内，输入我们的域名，就能看到blog上线咯</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Core-Image实战之二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/09/Core-Image实战之二/" class="article-date">
  	<time datetime="2016-11-09T01:15:24.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/Core-Image实战之二/">Core Image实战之二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>距离上一篇关于Core Image的文章已经过去4个月了……因为实习和找工作的原因，blog一直没有更新，实在是懒癌晚期。目前找工作早已告一段落，又稍稍休息了一段时间，现在也算有时间再弄弄blog吧。闲话不多说，上干货。</p>
<h2 id="CIFilter"><a href="#CIFilter" class="headerlink" title="CIFilter"></a>CIFilter</h2><p>Apple官方一共提供了14个大类的filter，具体如下：</p>
<ol>
<li>CICategoryBlur<br> 模糊滤镜，提供了高斯模糊，运动模糊等一系列的模糊效果。</li>
<li>CICategoryColorAdjustment<br> 色调调整，提供了色温，色相，曝光等一系列的调整效果。</li>
<li>CICategoryColorEffect<br> 色彩滤镜，提供了鲜艳，黑白等一系列的色彩滤镜。</li>
<li>CICategoryCompositeOperation<br> 混合效果，提供了图片混合的操作。</li>
<li>CICategoryDistortionEffect<br> 变形效果，提供了圆形扭曲，矩形扭曲等一系列变形。</li>
<li>CICategoryGenerator<br> 图像生成器，提供了二维码，条形码等图像的生成。</li>
<li>CICategoryGeometryAdjustment<br> 位置调整，提供了旋转，剪切等位置变换效果。</li>
<li>CICategoryGradient<br> 渐变效果，提供了高斯渐变，线性渐变等渐变图像的生成。</li>
<li>CICategoryHalftoneEffect<br> 网板效果，提供了雪花屏，线性屏等网板效果。</li>
<li>CICategoryReduction<br>降低效果，将图像的RGB值显示在图像中。</li>
<li>CICategorySharpen<br>锐化效果，提供了整体锐化和部分锐化效果。</li>
<li>CICategoryStylize<br>风格化效果，提供了发光，像素化等一系列的风格化滤镜效果。</li>
<li>CICategoryTileEffect<br>拼接效果，提供了万花筒，多边形拼接等一系列拼接效果。</li>
<li>CICategoryTransition<br>转屏效果，提供了淡入淡出，卷页等一系列的转屏效果。</li>
</ol>
<h3 id="CIFilter_u4E2D_u7684_u5751"><a href="#CIFilter_u4E2D_u7684_u5751" class="headerlink" title="CIFilter中的坑"></a>CIFilter中的坑</h3><p>由于CIFilter是基于KVO的编码方式，实际上的使用还是比较难用的。而且再加上像NSData这种不看官方文档完全无法知道里面data包含什么参数的类型，最坑的是官方文档中关于这类参数的介绍也是很少，对于新手来说，完全找不到北。只有在stackOverFlow中才有一些关于NSData里面到底应该传入什么数据的讨论。<br>举个例子，CIColorCube这个filter中有三个输入参数：</p>
<ol>
<li>inputImage，输入的图像，这个很好理解；</li>
<li>inputCubeDimension，输入的cube维度，第一次看完全懵逼，下面有介绍；</li>
<li>inputCubeData，cube的纹理，用作色彩查找表（CLUT）。<br>inputCubeDimension的类型是NSNumber，看起来好想不复杂，但是，这个NSNumber的值需要和CLUT的维度一致。如下图：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/LUT.png" alt="LUT图"><br>该图一共有 8 * 8 = 64个维度，因此，inputCubeDimension的值为64。</li>
</ol>
<p>inputCubeData的类型的NSData，看类型名完全不知道这个参数应该输入什么，而Apple官方文档中写的是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate and opulate color cube table</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">float</span> *cubeData = (<span class="keyword">float</span> *)malloc(size * size * size * <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; size; b++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">0</span>; g &lt; size; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; size; r ++) &#123;</span><br><span class="line">            cubeData[b][g][r][<span class="number">0</span>] = &lt;<span class="preprocessor"># output R value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">1</span>] = &lt;<span class="preprocessor"># output G value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">2</span>] = &lt;<span class="preprocessor"># output B value #&gt;;</span></span><br><span class="line">            cubeData[b][g][r][<span class="number">3</span>] = &lt;<span class="preprocessor"># output A value #&gt;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Put the table in a data object and create the filter</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytesNoCopy:cubeData</span><br><span class="line">                                    length:cubeDataSize</span><br><span class="line">                              freeWhenDone:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">CIFilter</span> *colorCube = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIColorCube"</span></span><br><span class="line">                           withInputParameters:@&#123;</span><br><span class="line">    <span class="string">@"inputCubeDimension"</span>: @(size),</span><br><span class="line">    <span class="string">@"inputCubeData"</span>: data,</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>在苹果的代码中，data成为了一个RGB的输入，而事实上该参数应该由一张LUT图来转换，根据stackOverFlow中关于CIColorCube的讨论，我写下了如下的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">NSData</span> *) colorCubeDataFromLUT:(<span class="built_in">UIImage</span> *)image withDimension:(<span class="built_in">NSInteger</span>)dimension</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> kDimension = dimension;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!image) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> width = <span class="built_in">CGImageGetWidth</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> height = <span class="built_in">CGImageGetHeight</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> rowNum = height / kDimension;</span><br><span class="line">    <span class="built_in">NSInteger</span> columnNum = width / kDimension;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((width % kDimension != <span class="number">0</span>) || (height % kDimension != <span class="number">0</span>) || (rowNum * columnNum != kDimension)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Invalid colorLUT"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> *bitmap = [<span class="keyword">self</span> createRGBABitmapFromImage:image<span class="variable">.CGImage</span>];</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Convert bitmap data written in row,column order to cube data written in x:r, y:g, z:b representation where z varies &gt; y varies &gt; x.</span></span><br><span class="line">    <span class="built_in">NSInteger</span> size = kDimension * kDimension * kDimension * <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">float</span> *data = malloc(size);</span><br><span class="line">    <span class="keyword">int</span> bitmapOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt;  rowNum; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kDimension; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = z;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; columnNum; col++) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> dataOffset = (z * kDimension * kDimension + y * kDimension) * <span class="number">4</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> divider = <span class="number">255.0</span>;</span><br><span class="line">                vDSP_vsdiv(&amp;bitmap[bitmapOffset], <span class="number">1</span>, &amp;divider, &amp;data[dataOffset], <span class="number">1</span>, kDimension * <span class="number">4</span>); <span class="comment">// Vector scalar divide; single precision. Divides bitmap values by 255.0 and puts them in data, processes each column (kDimension * 4 values) at once.</span></span><br><span class="line">                </span><br><span class="line">                bitmapOffset += kDimension * <span class="number">4</span>; <span class="comment">// shift bitmap offset to the next set of values, each values vector has (kDimension * 4) values.</span></span><br><span class="line">                z++;</span><br><span class="line">            &#125;</span><br><span class="line">            z = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        z += columnNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytesNoCopy:data length:size freeWhenDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span> *)createRGBABitmapFromImage:(<span class="built_in">CGImageRef</span>)image &#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bitmap;</span><br><span class="line">    <span class="built_in">NSInteger</span> bitmapSize;</span><br><span class="line">    <span class="built_in">NSInteger</span> bytesPerRow;</span><br><span class="line">    </span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(image);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(image);</span><br><span class="line">    </span><br><span class="line">    bytesPerRow   = (width * <span class="number">4</span>);</span><br><span class="line">    bitmapSize     = (bytesPerRow * height);</span><br><span class="line">    </span><br><span class="line">    bitmap = malloc( bitmapSize );</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">if</span> (colorSpace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(bitmap);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context = <span class="built_in">CGBitmapContextCreate</span> (bitmap,</span><br><span class="line">                                     width,</span><br><span class="line">                                     height,</span><br><span class="line">                                     <span class="number">8</span>,</span><br><span class="line">                                     bytesPerRow,</span><br><span class="line">                                     colorSpace,</span><br><span class="line">                                     (<span class="built_in">CGBitmapInfo</span>)k<span class="built_in">CGImageAlphaPremultipliedLast</span>);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>( colorSpace );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free (bitmap);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), image);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> *convertedBitmap = malloc(bitmapSize * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    vDSP_vfltu8(bitmap, <span class="number">1</span>, convertedBitmap, <span class="number">1</span>, bitmapSize); <span class="comment">// Converts an array of unsigned 8-bit integers to single-precision floating-point values.</span></span><br><span class="line">    free(bitmap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> convertedBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，就将inputCubeData的输入转为UIImage。</p>
<h2 id="Custom_Filter"><a href="#Custom_Filter" class="headerlink" title="Custom Filter"></a>Custom Filter</h2><p>和GPUImage一样，Core Image也支持自定义滤镜，但是需要注意的是：Core Image自定义滤镜采用The Core Image kernel language，大致和OpenGl一样，但是并不能无缝链接。比如不支持OpenGl shading的预处理以及mat2, mat3, mat4, struct, arrays。</p>
<h3 id="u4E00_u4E2A_u7B80_u5355_u7684_u81EA_u5B9A_u4E49_u6EE4_u955C"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u81EA_u5B9A_u4E49_u6EE4_u955C" class="headerlink" title="一个简单的自定义滤镜"></a>一个简单的自定义滤镜</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kernel vec4 YQMirrorVer(sampler image)</span><br><span class="line">&#123;</span><br><span class="line">    vec2 uv = samplerCoord(image);</span><br><span class="line">    uv = floor(uv*<span class="number">50.0</span>)/<span class="number">50.0</span>;</span><br><span class="line">    <span class="keyword">return</span> sample(image,uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们可以定义一个简单的马赛克滤镜shader，接着我们还需要定义一个类继承于CIFilter。其m文件如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CIKernel</span> *)YQMosaic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CIKernel</span> *kernelPrewitt = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBundle</span>    *bundle       = [<span class="built_in">NSBundle</span> bundleForClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"YQMosaic"</span>)];</span><br><span class="line">    <span class="built_in">NSStringEncoding</span> encoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line">    <span class="built_in">NSError</span>     *error        = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span>    *code         = [<span class="built_in">NSString</span> stringWithContentsOfFile:[bundle pathForResource:<span class="string">@"YQMosaic"</span> ofType:<span class="string">@"cikernel"</span>] encoding:encoding error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    kernelPrewitt             = [<span class="built_in">CIKernel</span> kernelWithString:code];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernelPrewitt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CIImage</span> *)outputImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CIImage</span> *result = <span class="keyword">self</span><span class="variable">.inputImage</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> YQMosaic] applyWithExtent:result<span class="variable">.extent</span></span><br><span class="line">                                roiCallback:^<span class="built_in">CGRect</span>(<span class="keyword">int</span> index, <span class="built_in">CGRect</span> rect) &#123;</span><br><span class="line">                                         <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(result<span class="variable">.extent</span>), <span class="built_in">CGRectGetHeight</span>(result<span class="variable">.extent</span>));</span><br><span class="line">                                     &#125;</span><br><span class="line">                                  arguments:@[result]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就自定义了一个我们自己的滤镜，可以直接像CIFilter一样使用。</p>
<p>参考资料</p>
<p>1.<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_blank" rel="external">Core Image Filter Reference</a> Apple<br>2.<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397" target="_blank" rel="external">Core Image Kernel Language Reference</a> Apple<br>3.<a href="https://github.com/FlexMonkey/Filterpedia" target="_blank" rel="external">Filterpedia</a> FlexMonkey </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GPUImage实战" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/07/GPUImage实战/" class="article-date">
  	<time datetime="2016-07-07T04:21:38.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/GPUImage实战/">Core Image实战之一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u5199_u5728_u524D_u9762"><a href="#u5199_u5728_u524D_u9762" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在公司做项目要用到Core Image，而之前对于CoreImage和GPUImage都基本没有了解过。于是趁着项目的驱动，做了一个小Demo。</p>
<h2 id="Core_Image_u7B80_u4ECB"><a href="#Core_Image_u7B80_u4ECB" class="headerlink" title="Core Image简介"></a>Core Image简介</h2><blockquote>
<p>Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.</p>
</blockquote>
<p>这是苹果官方文档对于Core Image的介绍，大致意思是：Core Image是一种为静态图像和video图像提供处理和分析的技术，它可以使用GPU/CPU的方式对图像进行处理。Core Image提供了简洁的API给用户，隐藏了图像处理中复杂的底层内容。你可以在不了解OpenGL、OpenGL ES甚至是GCD的基础上对其进行使用，他已经帮你对这些复杂的内容进行处理了。废话这么多，苹果就想告诉我们一件事：所有的底层细节他都帮你做好了，你只需要调用API就行了。</p>
<h2 id="u6EE4_u955C_u4E0E_u6EE4_u955C_u94FE"><a href="#u6EE4_u955C_u4E0E_u6EE4_u955C_u94FE" class="headerlink" title="滤镜与滤镜链"></a>滤镜与滤镜链</h2><p>一个滤镜是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。<br>一个滤镜图表是一个链接在一起的滤镜网络 (无回路有向图)，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。<br>Core Image的实现可以参考下面的图：<br><img src="http://7xqzfr.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-16%20%E4%B8%8B%E5%8D%885.18.40.png" alt=""><br>每个图片对象经过滤镜后作为下一个滤镜的输入（滤镜链），或者直接输出（单个滤镜）。</p>
<h2 id="Core_Image_u2019s_API"><a href="#Core_Image_u2019s_API" class="headerlink" title="Core Image’s API"></a>Core Image’s API</h2><p>Core Image的API主要就是三类：CIImage表示输入的图片；CIFilter表示经过的滤镜；CIContext表示上下文，可以从其中取得图片的信息。</p>
<ul>
<li><p>CIImage<br>保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。一般我们输入的都是UIImage，可以使用：imageWithCGImage:类方法获取CIImage。</p>
</li>
<li><p>CIFilter<br>滤镜类，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</p>
</li>
<li><p>CIContext<br>上下文类，如CoreGraphics以及CoreData中的上下文用于处理绘制渲染以及处理托管对象一样，CoreImage的上下文也是实现对图像处理的具体对象。<br>这里需要注意的是在Context创建的时候，我们需要给它设定为是基于GPU还是CPU。<br>基于GPU的话，处理速度更快，因为利用了GPU硬件的并行优势。但是GPU受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用CPU，因为当app切换到后台状态时GPU处理会被打断。</p>
</li>
</ul>
<h3 id="u4F7F_u7528_u6B65_u594F"><a href="#u4F7F_u7528_u6B65_u594F" class="headerlink" title="使用步奏"></a>使用步奏</h3><ol>
<li><p>创建图像上下文 CIContext</p>
</li>
<li><p>创建滤镜 CIFilter</p>
</li>
<li><p>创建过滤原图片 CIImage</p>
</li>
<li><p>调用 CIFilter 的 setValue:forKey:方法为滤镜指定源图片</p>
</li>
<li><p>设置滤镜参数【可选】</p>
</li>
<li><p>取得输出图片显示或保存</p>
</li>
</ol>
<p>具体实现可以参考最下面的Demo。</p>
<h2 id="GPUImage_u7B80_u4ECB"><a href="#GPUImage_u7B80_u4ECB" class="headerlink" title="GPUImage简介"></a>GPUImage简介</h2><blockquote>
<p>The GPUImage framework is a BSD-licensed iOS library that lets you apply GPU-accelerated filters and other effects to images, live camera video, and movies. In comparison to Core Image (part of iOS 5.0), GPUImage allows you to write your own custom filters, supports deployment to iOS 4.0, and has a simpler interface. However, it currently lacks some of the more advanced features of Core Image, such as facial detection.</p>
</blockquote>
<p>这是Brad Larson的Github对GPUImage做出的介绍，大致就是GPUImage以BSD协议放出，能够在图像、实时摄像头影像和视频上使用GPU加速的滤镜和其他效果。但是他相比于Core Image还是有不足的地方，就是他不支持面部检测。<br>GPUImage的使用和Core Image非常类似，也是将前一个滤镜的输出作为下一个滤镜的输入来实现滤镜链。</p>
<h2 id="GPUImage_u7684_u4F7F_u7528"><a href="#GPUImage_u7684_u4F7F_u7528" class="headerlink" title="GPUImage的使用"></a>GPUImage的使用</h2><p>Brad Larson在GPUImage的github上给出了使用方法，这里贴出来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *inputImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Lambeau.jpg"</span>];</span><br><span class="line"></span><br><span class="line">GP<span class="built_in">UImagePicture</span> *stillImageSource = [[GP<span class="built_in">UImagePicture</span> alloc] initWithImage:inputImage];</span><br><span class="line">GP<span class="built_in">UImageSepiaFilter</span> *stillImageFilter = [[GP<span class="built_in">UImageSepiaFilter</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[stillImageSource addTarget:stillImageFilter];</span><br><span class="line">[stillImageFilter useNextFrameForImageCapture];</span><br><span class="line">[stillImageSource processImage];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *currentFilteredVideoFrame = [stillImageFilter imageFromCurrentFramebuffer];</span><br></pre></td></tr></table></figure></p>
<p>如果只经过一个滤镜直接输出的话，可以简化为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GP<span class="built_in">UImageSepiaFilter</span> *stillImageFilter2 = [[GP<span class="built_in">UImageSepiaFilter</span> alloc] init];</span><br><span class="line"><span class="built_in">UIImage</span> *quickFilteredImage = [stillImageFilter2 imageByFilteringImage:inputImage];</span><br></pre></td></tr></table></figure>
<h2 id="u4E00_u4E2A_u7B80_u5355_u7684_u6EE4_u955CAPP"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u6EE4_u955CAPP" class="headerlink" title="一个简单的滤镜APP"></a>一个简单的滤镜APP</h2><p>前段时间用GPUImage做过一次，最近又用Core Image重构了一遍，两者的使用实际上差不了太多，下面是实际效果和代码。</p>
<p><img src="http://7xqzfr.com1.z0.glb.clouddn.com/coreimage.gif?imageView/2/w/300/q/90" alt=""></p>
<p>代码Demo<a href="https://github.com/oushiyq/YQCoreImageDemo" target="_blank" rel="external">在这</a> </p>
<p>参考资料</p>
<p>1.<a href="https://objccn.io/issue-21-6/" target="_blank" rel="external">Core Image 介绍</a> ObjC中国<br>2.<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html" target="_blank" rel="external">About Core Image</a> Apple<br>3.<a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a> BradLarson </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Daniel Young
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>